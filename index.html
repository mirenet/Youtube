<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Last.fm Player Styled</title>

<style>
:root {
  --bg-top: #0F0F0F;
  --bg-bottom: #000000;
  --btn-accent: #CBD868;
  --btn-muted: #B9ADA1;
  --artist-col: #959398;
  --track-col: #3E3D43;
  --bio-col: #3E3D43;
  --progress-col: #C8D86D;
}

html, body {
  overflow: hidden; /* zabrani skrol */
  height: 100%;
  margin: 0;

  background:
    url("wallpaper-1.jpg") no-repeat center center fixed,
    linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
    url("wallpaper-2.jpg") no-repeat center center fixed,
    #0F0F0F;

  background-size: cover, cover, cover, auto;
  background-attachment: fixed, fixed, fixed, scroll;
  background-position: center center, center center, center center, initial;

  font-family: Inter, "Arial", sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
}

.player {
  width: 380px;
  padding: 20px;
  padding-top: env(safe-area-inset-top, 10px);
  padding-bottom: env(safe-area-inset-bottom);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  box-shadow: 0 8px 20px rgba(0,0,0,0.6);
  background: var(--bg);
  border-radius: 12px;
  height: 100vh;

}

.top-bar {
  flex: 0 0 60px;
  position: fixed;
  top: env(safe-area-inset-top, 10px);
  width: 90%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 6px;
  padding: 0 15px;
  z-index: 100; /* dodato */
}


.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow: hidden;
  width: 100%; 
}





.icon-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--btn-muted);
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.12);
}

.plus {
  color: #000;
  font-weight: 700;
  font-size: 25px;
}

.heart {
  position: relative;
  width: 10px;
  height: 10px;
  background: black;
  transform: rotate(-45deg);
  left: 0.4px;
  top: 2px;
}

.heart:before,
.heart:after {
  content: "";
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: black;
}

.heart:before { top: -6px; left: 0; }
.heart:after  { left: 6px; top: 0; }

.album-wrap {
  position: relative;
  width: 300px;
  height: 300px;
  margin-top: 58px;
  margin-bottom: 6px;
}

.progress {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  --p: 28;
  background: conic-gradient(var(--progress-col) calc(var(--p)*1%), rgba(255,255,255,0) 0);
  transform: rotate(-90deg);
  mask: radial-gradient(farthest-side, transparent 98%, black 99%);
  -webkit-mask: radial-gradient(farthest-side, transparent 98%, black 99%);
  z-index: 1;
}

.progress {
display: none;
}

.album-img {
  position: absolute;
  width: 270px;
  height: 270px;
  border-radius: 50%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  object-fit: cover;
  object-position: center top; /* lice bliže vrhu */
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  z-index: 2;
}

.album-img[src=""],
.album-img[alt]:not([src]) {
  display: none;
}

.track-info {
  display: flex;
  flex-direction: column;
  align-items: center;  
  text-align: center;
  margin-top: -20px;
  margin-bottom: 10px;
  width: 100%;
}

.artist {
  color: #8AA7B8;
  font-weight: 700;
  font-size: 18px;
  margin-top: 15px;
  margin-bottom: 6px;
  white-space: nowrap;    
  overflow: hidden;            
  text-overflow: ellipsis;  
  max-width: 270px;        
} 

.track {
  color: #E03A44;
  font-weight: 500;
  font-size: 15px;
  margin-bottom: 3px;
  white-space: nowrap;      
  overflow: hidden;             
  text-overflow: ellipsis;  
  max-width: 270px;         
}

.bio-wrap {
  flex: 1;    /* da se siri */
  width: 90%;
  overflow-y: auto;
  padding-bottom: 100px; /* visina controls */
  position: relative;
}

.bio {
  height: 100%;
  overflow-y: auto;
  padding: 6px 8px;
  box-sizing: border-box;
  color: #9E9DA4;
  font-size: 14px;
  line-height: 1.45;
  text-align: left; 
} 


.controls {
  position: fixed;
  bottom: env(safe-area-inset-bottom, 10px);
  display: flex;
  gap: 18px;
  align-items: center;
  justify-content: center;
  width: 100%;
  margin-bottom: 5px;
}




.ctrl {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(0,0,0,0.5);
}
.ctrl.small {
  width: 44px;
  height: 44px;
  background: #B9ADA2;
  color: #000000;
  border: 1px solid rgba(255,255,255,0.03);
}
.ctrl.play {
  width: 60px;
  height: 60px;
  background: var(--btn-accent);
  color: #000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.app-title {
  text-align: center;
  font-weight: 700;
  font-size: 18px;
  color: var(--btn-accent);
  margin-top: 1px;
}

:root {
  --icon-scale: 0.80; 
}

.ico {
  display: inline-block;
  position: relative;
}

.ico.plus {
  width: calc(20px * var(--icon-scale));
  height: calc(4px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
}
.ico.plus::after {
  content: "";
  position: absolute;
  left: 50%;
  top: calc(-8px * var(--icon-scale));
  width: calc(4px * var(--icon-scale));
  height: calc(20px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
  transform: translateX(-50%);
}

.ico.play {
  width: 0;
  height: 0;
  border-top: calc(13px * var(--icon-scale)) solid transparent;
  border-bottom: calc(13px * var(--icon-scale)) solid transparent;
  border-left: calc(20px * var(--icon-scale)) solid #000;
  border-radius: 3px;
  transform: translateX(2px);
}

.ico.stop {
  width: calc(17px * var(--icon-scale));
  height: calc(17px * var(--icon-scale));
  background: #000;
  border-radius: 3px;
}

.ico.next {
  width: 0;
  height: 0;
  border-top: calc(10px * var(--icon-scale)) solid transparent;
  border-bottom: calc(10px * var(--icon-scale)) solid transparent;
  border-left: calc(16px * var(--icon-scale)) solid #000;
  border-radius: 3px;
  transform: translateX(-2px);
}
.ico.next::after {
  content: "";
  position: absolute;
  top: calc(-9px * var(--icon-scale));
  right: calc(-6px * var(--icon-scale));
  width: calc(4px * var(--icon-scale));
  height: calc(18px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
}

.popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 420px;
  background: #1a1a1c;
  border-radius: 12px;
  padding: 16px;
  z-index: 1000;
}

.popup h3 { margin: 0 0 10px 0; color: #CBD868; }
.popup label { display:block; margin-top:8px; color:#ddd; font-size:13px;}
.popup input, .popup select, .popup textarea {
  width: 100%;
  padding: 8px;
  margin-top:4px;
  border-radius: 8px;
  background: #111;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.06);
  box-sizing: border-box;
}

.popup .row { display:flex; gap:8px; margin-top:8px; }
.popup .row button { flex:1; padding:8px; border-radius:8px; border:none; cursor:pointer; }

.dropdown {
  position: absolute;
  top: 60px;
  left: 20px;
  display: none;
  flex-direction: column;
  background: #1a1a1c;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  z-index: 101; /* dodato */
}

.dropdown button {
  width: 100%;
  padding: 8px 12px;
  border: none;
  background: none;
  color: #fff;
  text-align: left;
  cursor: pointer;
}

.dropdown button:hover {
  background: var(--btn-accent);
  color: #000;
}

.toast {
visibility: hidden;
min-width: 160px;
max-width: 320px;
background-color: rgba(83,82,85,0.95);
color: #fff;
text-align: center;
border-radius: 24px;
padding: 14px 24px;
position: fixed;
bottom: 80px;
left: 50%;
transform: translateX(-50%);
font-size: 15px;
font-family: sans-serif;
box-shadow: 0 2px 10px rgba(0,0,0,0.3);
z-index: 9999;
opacity: 0;
pointer-events: none;
transition: opacity 0.25s ease-in-out, bottom 0.25s ease-in-out;
}

.toast.show {
visibility: visible;
opacity: 1;
bottom: 100px;
}

/* Vrati korisnika u portrait mode*/
#portraitOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000;
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-size: 18px;
  font-family: sans-serif;
  z-index: 9999;
  padding: 20px;
  box-sizing: border-box;
  display: none; /* default hidden */
}

.hidden-file-input {
  display:none;
}

</style>
</head>

<body>
<div class="player">
  <div class="top-bar">
    <div class="icon-circle" id="plusBtn"><span class="ico plus" aria-hidden="true"></span></div>
    <h1 class="app-title">Last.Fm</h1>
    <div class="icon-circle" id="heartBtn"><div class="heart" aria-hidden="true"></div></div>
  </div>

  <!-- dropdown je apsolutno pozicioniran unutar .player -->
  <div class="dropdown" id="plusDropdown" aria-hidden="true">
    <button id="startRadioBtn">Start Radio</button>
    <button id="setVarietyBtn">Set Variety</button>
    <button id="settingsBtn" style="border-top:1px solid rgba(255,255,255,0.03); margin-top:6px;">Settings</button>
  </div>

  <!-- content zauzima prostor između top-bar i controls -->
  <div class="content">
    <div class="timer" id="status"></div>
    <div class="debug" id="debugArea"></div>

    <div class="album-wrap">
      <div class="progress" style="--p:0;"></div>
      <img class="album-img" src="" alt="Artist photo" id="albumImg">
    </div>

    <div class="track-info">
      <div class="artist" id="artistName">‎ </div>
      <div class="track" id="trackName">‎ </div>
    </div>

    <div class="bio-wrap">
      <div class="bio" id="bio">‎ </div>
    </div>
  </div>

  <!-- controls uvek na dnu -->
  <div class="controls">
    <div class="ctrl small" id="stopBtn"><span class="ico stop" aria-hidden="true"></span></div>
    <div class="ctrl play" id="playBtn"><span class="ico play" aria-hidden="true"></span></div>
    <div class="ctrl small" id="nextBtn"><span class="ico next" aria-hidden="true"></span></div>
  </div>

  <div id="popupStartRadio" class="popup">
    <input type="text" id="popupInputStart" placeholder="Enter artist name">
    <div class="row"><button id="popupStartBtn" style="background:var(--btn-accent); color:#000">Start</button></div>
  </div>

  <div id="popupSetVariety" class="popup">
    <h3>Variety</h3>
    <label>Max Similar Artists:</label>
    <input type="number" id="maxSimilarInput" value="250" min="1" max="2000">
    <label>Max Track Pages:</label>
    <input type="number" id="maxTrackInput" value="2" min="1" max="50">
    <div class="row">
      <button id="popupVarietyClose" style="background:var(--btn-accent); color:#000">Close</button>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="popup" aria-hidden="true">
    <h3>Settings</h3>

    <label>Audio Player</label>
    <select id="audioPlayerSelect">
      <option value="default">Default (embedded)</option>
      <option value="newpipe">NewPipe (intent)</option>
    </select>

    <label>Last.Fm API</label>
    <input type="text" id="lastfmInput" placeholder="Last.fm API key">

    <label>Discogs API</label>
    <input type="text" id="discogsInput" placeholder="Discogs token">

    <label>Spotify Client ID</label>
    <input type="text" id="spotifyIdInput" placeholder="Spotify Client ID">

    <label>Spotify Client Secret</label>
    <input type="text" id="spotifySecretInput" placeholder="Spotify Client Secret">

    <label>Proxy Worker</label>
    <input type="text" id="proxyInput" placeholder="Proxy worker URL">

    <div style="display:flex; gap:8px; margin-top:12px;">
      <button id="importBtn" style="flex:1; background:#222; color:#fff;">Import Settings</button>
      <button id="exportBtn" style="flex:1; background:var(--btn-accent); color:#000;">Export Settings</button>
    </div>

    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="saveSettingsBtn" style="flex:1; background:var(--btn-accent); color:#000;">Save</button>
      <button id="closeSettingsBtn" style="flex:1; background:#333; color:#fff;">Close</button>
    </div>
    <input type="file" id="importFile" class="hidden-file-input" accept=".json" />
  </div>

</div>

<!-- SKRIVENI YT PLAYER (u potpunosti sakriven) -->
<div id="ytPlayerContainer" style="position:fixed; width:0; height:0; overflow:hidden; left:-9999px; top:-9999px; opacity:0; pointer-events:none;">
  <div id="ytPlayer"></div>
</div>

<div id="toast" class="toast"></div>

<div id="portraitOverlay">
  This app work only in portrait mode!<br>Please, rotate your device!
</div>

<script>
/* ====== GLOBAL CONFIG (hardcoded defaults - can be changed in Settings) ====== */
let PROXY_URL = 'https://mire021.mireinternet.workers.dev?url=';
let LASTFM_API_KEY = 'e5147a4d5b2018c3832b146b74b61061'; // default - can be blanked
let DISCOGS_TOKEN = 'MrikosMJLcAbEUiXPnwsstSRPzQvnAEOHDEcoTaM';
let SPOTIFY_CLIENT_ID = 'd7308ace981d46d385bab314f8ef0546';
let SPOTIFY_CLIENT_SECRET = '707748e12786459dba6982c82bdd8d51';

let audioPlayerChoice = 'default'; // 'default' or 'newpipe'
let maxSimilarPages = 250, maxTrackPages = 2;

const EMPTY_VIDEO_URL = "https://www.youtube.com/watch?v=tbnLqRW9Ef0";

/* ====== END GLOBAL CONFIG ====== */

let baseArtist = '', currentArtistOnScreen = '', currentVideoUrl = '', currentVideoUrlArtist = '', currentVideoUrlTrack = '', preloadCache = null;

/* --- Helper functions --- */
function debug(msg){
  const dbg = document.getElementById('debugArea');
  if(dbg) dbg.textContent = msg;
}
function normalizeArtistForDisplay(a){ return a.replace(/\+/g,' '); }
function normalizeArtistForSearch(a){ return a.replace(/ /g,'+'); }
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
function showToast(msg, duration=2500){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(()=> t.classList.remove('show'), duration);
}

/* --- Persist / Load settings from localStorage --- */
const SETTINGS_KEY = 'LFM_settings_v1';

function saveSettingsToLocalStorage(){
  const s = {
    audioPlayerChoice,
    LASTFM_API_KEY,
    DISCOGS_TOKEN,
    SPOTIFY_CLIENT_ID,
    SPOTIFY_CLIENT_SECRET,
    PROXY_URL,
    maxSimilarPages,
    maxTrackPages
  };
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
}

function loadSettingsFromLocalStorage(){
  try{
    const raw = localStorage.getItem(SETTINGS_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(s.audioPlayerChoice) audioPlayerChoice = s.audioPlayerChoice;
    if(s.LASTFM_API_KEY !== undefined) LASTFM_API_KEY = s.LASTFM_API_KEY;
    if(s.DISCOGS_TOKEN !== undefined) DISCOGS_TOKEN = s.DISCOGS_TOKEN;
    if(s.SPOTIFY_CLIENT_ID !== undefined) SPOTIFY_CLIENT_ID = s.SPOTIFY_CLIENT_ID;
    if(s.SPOTIFY_CLIENT_SECRET !== undefined) SPOTIFY_CLIENT_SECRET = s.SPOTIFY_CLIENT_SECRET;
    if(s.PROXY_URL !== undefined) PROXY_URL = s.PROXY_URL;
    if(s.maxSimilarPages) maxSimilarPages = s.maxSimilarPages;
    if(s.maxTrackPages) maxTrackPages = s.maxTrackPages;
  }catch(e){ console.warn("Failed load settings", e); }
}

/* Initialize settings from localStorage on load */
loadSettingsFromLocalStorage();

/* Fill Settings modal inputs from current values */
function populateSettingsModal(){
  document.getElementById('audioPlayerSelect').value = audioPlayerChoice || 'default';
  document.getElementById('lastfmInput').value = LASTFM_API_KEY || '';
  document.getElementById('discogsInput').value = DISCOGS_TOKEN || '';
  document.getElementById('spotifyIdInput').value = SPOTIFY_CLIENT_ID || '';
  document.getElementById('spotifySecretInput').value = SPOTIFY_CLIENT_SECRET || '';
  document.getElementById('proxyInput').value = PROXY_URL || '';
  document.getElementById('maxSimilarInput').value = maxSimilarPages;
  document.getElementById('maxTrackInput').value = maxTrackPages;
}

/* Apply settings from inputs to runtime variables */
function applySettingsFromModal(){
  audioPlayerChoice = document.getElementById('audioPlayerSelect').value || 'default';
  LASTFM_API_KEY = document.getElementById('lastfmInput').value.trim();
  DISCOGS_TOKEN = document.getElementById('discogsInput').value.trim();
  SPOTIFY_CLIENT_ID = document.getElementById('spotifyIdInput').value.trim();
  SPOTIFY_CLIENT_SECRET = document.getElementById('spotifySecretInput').value.trim();
  PROXY_URL = document.getElementById('proxyInput').value.trim() || PROXY_URL;
  maxSimilarPages = parseInt(document.getElementById('maxSimilarInput').value) || maxSimilarPages;
  maxTrackPages = parseInt(document.getElementById('maxTrackInput').value) || maxTrackPages;
  saveSettingsToLocalStorage();
}

/* ====== Last.fm / Discogs / Spotify helpers (use global variables above) ====== */

/* --- Last.fm - Top Tracks --- */
async function getRandomTopTrack(artist){
    try {
        const urlPage1 = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artist)}&api_key=${LASTFM_API_KEY}&format=json&limit=50&page=1`;
        const resPage1 = await fetch(urlPage1);
        const dataPage1 = await resPage1.json();

        const totalPages = parseInt(dataPage1.toptracks?.['@attr']?.totalPages || 1, 10) || 1;
        const maxPages = Math.min(totalPages, maxTrackPages);
        await sleep(1000);
        const page = Math.floor(Math.random() * maxPages) + 1;
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artist)}&api_key=${LASTFM_API_KEY}&format=json&limit=50&page=${page}`;
        const res = await fetch(url);
        const data = await res.json();

        const tracks = data.toptracks && data.toptracks.track ? data.toptracks.track.map(t => t.name) : [];
        if(tracks.length === 0) return 'Demo Track';
        return tracks[Math.floor(Math.random() * tracks.length)];

    } catch(e) {
        console.error("getRandomTopTrack failed", e);
        return 'Demo Track';
    }
}

/* --- Last.fm - Similar Artists --- */
async function getRandomSimilarArtist(){
    try{
        if(!baseArtist) return '';
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=${encodeURIComponent(baseArtist)}&api_key=${LASTFM_API_KEY}&format=json&limit=${maxSimilarPages}`;
        const res = await fetch(url);
        const data = await res.json();
        const artists = data.similarartists && data.similarartists.artist ? data.similarartists.artist.map(a=>a.name) : [];
        if(artists.length) return artists[Math.floor(Math.random()*artists.length)];
        return baseArtist;
    } catch(e){ return baseArtist; }
}

/* --- Last.fm Bio + Discogs/Spotify Images --- */
async function getArtistImagesAndBio(artist) {
    try {
        const bioAndInfo = await fetchLastFmBioShort(artist);
        const spotifyImages = await fetchSpotifyImages(artist);
        const discogsImages = await fetchDiscogsImage(artist, DISCOGS_TOKEN);
        const images = [...spotifyImages, ...discogsImages.filter(img => !spotifyImages.includes(img))];
        return { bio: bioAndInfo, images: images.length ? images : [] };
    } catch (e) {
        console.error(e);
        return { bio: "Biography not found.", images: [] };
    }

    async function fetchLastFmBioShort(artistName) {
        try {
            const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${LASTFM_API_KEY}&format=json`;
            const res = await fetch(url);
            const data = await res.json();

            let bio = data.artist?.bio?.content?.trim() || "Biography not found.";
            let readMoreLink = "";
            const match = bio.match(/<a href="([^"]+)">.*?<\/a>/i);
            if (match) { readMoreLink = ''; bio = bio.replace(/<a href="[^"]+">.*?<\/a>/i, ""); }

            const stats = data.artist?.stats || {};
            const tags = data.artist?.tags?.tag?.map(t => t.name).join(", ") || "";
            const similar = data.artist?.similar?.artist?.map(a => a.name).join(", ") || "";

            let extra = "";
            if (stats.listeners) extra += `<br>Listeners: ${stats.listeners}`;
            if (stats.playcount) extra += `<br>Playcount: ${stats.playcount}`;
            if (tags) extra += `<br>Genre: ${tags}`;
            if (similar) extra += `<br>Similar Artists: ${similar}`;

            if (extra) extra = `<br>${extra}`;

            return `${bio}${extra}${readMoreLink}`;
        } catch (e) {
            console.error("Last.fm bio fetch failed", e);
            return "Biography not found.";
        }
    }
}

/* --- Spotify Images --- */
async function fetchSpotifyImages(artistName, maxImages = 10, enabled = true) {
    if (!enabled) return []; 
    try {
        if(!SPOTIFY_CLIENT_ID || !SPOTIFY_CLIENT_SECRET) return [];
        const resp = await fetch("https://accounts.spotify.com/api/token", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Authorization": "Basic " + btoa(SPOTIFY_CLIENT_ID + ":" + SPOTIFY_CLIENT_SECRET)
            },
            body: "grant_type=client_credentials"
        });
        const data = await resp.json();
        const token = data.access_token;
        const searchRes = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(artistName)}&type=artist&limit=50`, {
            headers: { "Authorization": `Bearer ${token}` }
        });
        const searchData = await searchRes.json();
        const artist = searchData.artists?.items?.[0];
        if (!artist || !artist.images) return [];
        const preferredSizes = [640, 320, 160];
        let selected = [];
        for (let size of preferredSizes) {
            selected = artist.images
                .filter(img => img.width === size && img.height === size)
                .slice(0, maxImages)
                .map(img => img.url);
            if (selected.length > 0) break;
        }
        if (selected.length === 0 && artist.images.length > 0) {
            const largest = artist.images.sort((a,b) => (b.width*b.height)-(a.width*a.height))[0];
            selected = [largest.url];
        }
        return selected;
    } catch (e) {
        console.warn("Spotify image fetch failed", e);
        return [];
    }
}

/* --- Discogs Images --- */
async function fetchDiscogsImage(artistName, token, minWidth = 1500, minHeight = 1500, maxImages = 5, randomize = true, enabled = true) { 
    if (!enabled) return []; 
    try {
        if(!token) return [];
        const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(artistName)}&type=artist&token=${token}`;
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (!searchData.results || searchData.results.length === 0) return [];
        const firstResult = searchData.results[0];
        const coverImage = firstResult.cover_image || null;
        const artistId = firstResult.id;
        await sleep(1000);
        const artistUrl = `https://api.discogs.com/artists/${artistId}?token=${token}`;
        const artistRes = await fetch(artistUrl);
        const artistData = await artistRes.json();
        if (!artistData.images || artistData.images.length === 0) {
            return coverImage ? [coverImage] : [];
        }
        let allImages = [];
        if (coverImage) allImages.push({ uri: coverImage, width: 0, height: 0, area: 0, type: "cover" });
        artistData.images.forEach(img => {
            allImages.push({
                uri: img.uri,
                width: img.width,
                height: img.height,
                area: img.width * img.height,
                type: img.type
            });
        });
        if (coverImage) {
            allImages = allImages.filter((img, idx, arr) => !(img.uri === coverImage && idx !== arr.findIndex(i => i.uri === coverImage)));
        }
        let candidates = allImages.filter(img => img.width >= minWidth && img.height >= minHeight);
        if (candidates.length === 0) candidates = [...allImages].sort((a, b) => b.area - a.area);
        let selected;
        if (randomize) {
            selected = [];
            let pool = [...candidates];
            while (pool.length > 0 && selected.length < maxImages) {
                const idx = Math.floor(Math.random() * pool.length);
                selected.push(pool[idx]);
                pool.splice(idx, 1);
            }
        } else {
            selected = candidates.slice(0, maxImages);
        }
        if (coverImage && !selected.find(img => img.uri === coverImage)) {
            if (selected.length < maxImages) {
                selected.push({ uri: coverImage, width: 0, height: 0, area: 0, type: "cover" });
            }
        }
        selected.sort((a, b) => b.area - a.area);
        return selected.map(img => img.uri);
    } catch (e) {
        console.error("Discogs image fetch failed", e);
        return [];
    }
}

/* --- Carousel --- */
let carouselInterval = null;
function renderCarousel(images){
    const imgEl = document.getElementById('albumImg');
    if(!images || !images.length){ imgEl.src=''; return; }
    let idx = 0; imgEl.src = images[idx];
    if(carouselInterval) clearInterval(carouselInterval);
    carouselInterval = setInterval(()=>{ idx=(idx+1)%images.length; imgEl.src=images[idx]; }, 10000);
}

/* --- YouTube search via proxy --- */
const INV_INSTANCES = [
  "https://yewtu.be",
  "https://invidious.snopyta.org",
  "https://vid.puffyan.us",
  "https://invidious.kavin.rocks",
  "https://invidious.tiekoetter.com"
];

async function searchYouTubeHtml(query){
    const BLACKLIST = ["remix","extended","album","live","mix","cover","tribute","instrumental","karaoke"];
    function containsBlacklist(str){ return BLACKLIST.some(b=>str.toLowerCase().includes(b)); }

    async function searchYTHTML(q){
        try {
            const url = `https://www.youtube.com/results?search_query=${encodeURIComponent(q)}`;
            const html = await fetch(PROXY_URL + encodeURIComponent(url)).then(r=>r.text());
            const match = html.match(/var ytInitialData = (.*?);\s*<\/script>/);
            if(!match) throw new Error("ytInitialData not found");
            const data = JSON.parse(match[1]);
            const contents = data.contents
              .twoColumnSearchResultsRenderer.primaryContents
              .sectionListRenderer.contents[0].itemSectionRenderer.contents;
            const videos = contents.filter(x=>x.videoRenderer).map(x=>x.videoRenderer);
            if(!videos.length) throw new Error("No videos found");

            const queryHasBlacklist = containsBlacklist(q);
            const artist = q.split('-')[0].trim().toLowerCase();
            const qNoDash = q.replace(/-/g,'').replace(/\s+/g,' ').trim();

            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase() === q.toLowerCase()) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase().replace(/-/g,'').includes(qNoDash.toLowerCase())) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase().includes(q.toLowerCase())) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(title.toLowerCase().includes(artist)) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            return "https://www.youtube.com/watch?v="+videos[0].videoId;
        } catch(e) {
            throw new Error("YT HTML failed: "+e.message);
        }
    }

    async function searchInvidious(q){
        for(const baseUrl of INV_INSTANCES){
            try{
                const searchUrl = `${baseUrl}/search?q=${encodeURIComponent(q)}`;
                const html = await fetch(PROXY_URL + encodeURIComponent(searchUrl)).then(r=>r.text());
                const doc = new DOMParser().parseFromString(html,'text/html');
                const links = [...doc.querySelectorAll('a[href*="/watch?v="]')];
                const queryHasBlacklist = containsBlacklist(q);
                for(const link of links){
                    const title = link.getAttribute('title') || link.textContent;
                    if(!title) continue;
                    if(!queryHasBlacklist && containsBlacklist(title)) continue;
                    if(title.toLowerCase().includes(q.toLowerCase())){
                        const href = link.getAttribute('href');
                        return href.startsWith('http') ? href : baseUrl + href;
                    }
                }
                if(links.length){
                    const href = links[0].getAttribute('href');
                    return href.startsWith('http') ? href : baseUrl + href;
                }
            }catch(e){ continue; }
        }
        throw new Error("Invidious failed");
    }

    try{
        const url = await searchYTHTML(query);
        return url;
    }catch(e){
        console.warn("YT HTML failed, switching to Invidious:", e);
        showToast("YT HTML search failed, switching to Invidious...");
        try{
            const url = await searchInvidious(query);
            showToast("Invidious search succeeded.");
            return url;
        }catch(e2){
            showToast("Neither YT HTML nor Invidious worked!");
            throw new Error("No source available");
        }
    }
}

/* Build NewPipe intent url */
function buildIntentUrl(youtubeUrl){
  if(!youtubeUrl) return '';
  const clean = youtubeUrl.replace(/^https?:\/\//,'');
  return `intent://${clean}#Intent;package=org.schabi.newpipe;scheme=https;end`;
}

/* ====== YT IFRAME PLAYER (hidden) ====== */
let ytPlayer = null;
let ytApiLoaded = false;

function loadYouTubeIframeAPI(){
  if(window.YT && YT.Player){
    ytApiLoaded = true;
    createYTPlayerIfNeeded();
    return;
  }
  if(document.getElementById('youtube-iframe-api')) return;
  const tag = document.createElement('script');
  tag.id = 'youtube-iframe-api';
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}

function onYouTubeIframeAPIReady(){
  ytApiLoaded = true;
  createYTPlayerIfNeeded();
}

function createYTPlayerIfNeeded(){
  if(!ytApiLoaded) return;
  if(ytPlayer) return;
  ytPlayer = new YT.Player('ytPlayer', {
    height: '0',
    width: '0',
    playerVars: {
      autoplay: 0,
      controls: 0,
      modestbranding: 1,
      rel: 0,
      playsinline: 1,
      disablekb: 1,
      iv_load_policy: 3,
      fs: 0
    },
    events: {
      'onReady': (e) => {},
      'onStateChange': onYTStateChange,
      'onError': (e)=> { console.warn("YT player error", e); }
    }
  });
}

function getYouTubeID(url){
  if(!url) return null;
  const patterns = [
    /(?:youtu\.be\/)([A-Za-z0-9_\-]{11})/,
    /(?:v=)([A-Za-z0-9_\-]{11})/,
    /(?:embed\/)([A-Za-z0-9_\-]{11})/,
    /(?:\/v\/)([A-Za-z0-9_\-]{11})/,
    /([A-Za-z0-9_\-]{11})$/ // fallback
  ];
  for(const p of patterns){
    const m = url.match(p);
    if(m && m[1]) return m[1];
  }
  return null;
}

function onYTStateChange(event){
  try{
    if(event.data === YT.PlayerState.ENDED){
      // auto next
      try{ next(); }catch(e){ console.warn("Auto-next failed", e); }
    }
  }catch(e){
    console.warn('onYTStateChange error', e);
  }
}

function cueAndPlayUrl(youtubeUrl, autoplay = true){
  if(!youtubeUrl) return;
  const vid = getYouTubeID(youtubeUrl);
  if(!vid) { console.warn('Invalid YouTube URL:', youtubeUrl); return; }
  loadYouTubeIframeAPI();
  const tryLoad = () => {
    if(ytPlayer && typeof ytPlayer.loadVideoById === 'function'){
      try {
        ytPlayer.loadVideoById(vid);
        if(autoplay){
          setTimeout(()=>{ try{ ytPlayer.playVideo(); }catch(e){ console.warn("playVideo failed", e); } }, 150);
        }
      } catch(e) { console.warn("Couldn't load video into ytPlayer", e); }
      return true;
    }
    return false;
  };
  if(!tryLoad()){
    let attempts = 0;
    const int = setInterval(()=> {
      attempts++;
      if(tryLoad() || attempts > 50) clearInterval(int);
    }, 200);
  }
}

/* ====== Preload + main flow ====== */
async function preloadNextTrack(){
    if(!baseArtist) return;
    const pickArtist = await getRandomSimilarArtist();
    await sleep(1000);
    const {images, bio} = await getArtistImagesAndBio(pickArtist);
    await sleep(1000);
    const pickTrack = await getRandomTopTrack(pickArtist);
    await sleep(1000);
    const youtubeUrl = await searchYouTubeHtml(`${normalizeArtistForSearch(pickArtist)} - ${pickTrack}`);
    preloadCache = { artist: pickArtist, track: pickTrack, images, bio, youtubeUrl };
}

async function loadArtist(artist) {
    baseArtist = artist;
    currentArtistOnScreen = artist;
    const appTitle = document.querySelector('.app-title');
    const originalTitle = appTitle.textContent;
    appTitle.textContent = 'Loading...';
    try {
        const { bio, images } = await getArtistImagesAndBio(artist);
        await sleep(1000);
        const pickTrack = await getRandomTopTrack(artist);
        await sleep(1000);
        const youtubeUrl = await searchYouTubeHtml(`${normalizeArtistForSearch(artist)} - ${pickTrack}`);
        document.getElementById('bio').innerHTML = bio.replace(/\n/g, '<br>');
        renderCarousel(images);
        document.getElementById('artistName').textContent = normalizeArtistForDisplay(artist);
        document.getElementById('trackName').textContent = pickTrack;
        currentVideoUrl = youtubeUrl;
        currentVideoUrlArtist = artist;
        currentVideoUrlTrack = pickTrack;
        preloadNextTrack();
    } catch (e) {
        console.error("loadArtist failed", e);
        document.getElementById('bio').textContent = "Error loading artist.";
    } finally {
        appTitle.textContent = originalTitle;
    }
}

/* --- Play Video --- */
async function play(){
    if(!currentVideoUrl) return;
    if(audioPlayerChoice === 'newpipe'){
      // open as intent -> NewPipe app (navigates away)
      const intentUri = buildIntentUrl(currentVideoUrl);
      window.location.href = intentUri;
    } else {
      // use hidden embed player
      cueAndPlayUrl(currentVideoUrl, true);
    }
}

/* ---- Next Video ---- */
async function next(){
    if(preloadCache){
        const {artist, track, images, bio, youtubeUrl} = preloadCache;
        currentArtistOnScreen = artist;
        document.getElementById('artistName').textContent = normalizeArtistForDisplay(artist);
        document.getElementById('trackName').textContent = track;
        document.getElementById('bio').innerHTML = bio.replace(/\n/g, '<br>');
        renderCarousel(images);
        currentVideoUrl = youtubeUrl;
        currentVideoUrlArtist = artist;
        currentVideoUrlTrack = track;
        // choose playback mode based on settings
        if(audioPlayerChoice === 'newpipe'){
          const intentUri = buildIntentUrl(youtubeUrl);
          window.location.href = intentUri;
        } else {
          cueAndPlayUrl(youtubeUrl, true);
        }
        preloadNextTrack();
    } else {
      showToast("No next track prepared yet.");
    }
}

/*---- Stop Video ----*/
function stopVideo(){
    if(audioPlayerChoice === 'newpipe'){
      // for newpipe case, we can't stop app; as fallback do nothing or navigate to empty
      try{ window.location.href = buildIntentUrl(EMPTY_VIDEO_URL); }catch(e){}
    } else {
      try{ if(ytPlayer && typeof ytPlayer.stopVideo === 'function') ytPlayer.stopVideo(); }catch(e){}
      currentVideoUrl = EMPTY_VIDEO_URL;
    }
}

/* --- Event listeners --- */
document.getElementById('playBtn').addEventListener('click', play);
document.getElementById('nextBtn').addEventListener('click', next);
document.getElementById('stopBtn').addEventListener('click', stopVideo);

const plusBtn = document.getElementById('plusBtn');
const plusDropdown = document.getElementById('plusDropdown');
plusBtn.addEventListener('click', ()=>{
  plusDropdown.style.display = plusDropdown.style.display==='flex' ? 'none' : 'flex';
});

/* Dropdown actions */
const startRadioBtn = document.getElementById('startRadioBtn');
const setVarietyBtn = document.getElementById('setVarietyBtn');
const settingsBtn = document.getElementById('settingsBtn');
const popupStartRadio = document.getElementById('popupStartRadio');
const popupSetVariety = document.getElementById('popupSetVariety');
const settingsModal = document.getElementById('settingsModal');

startRadioBtn.addEventListener('click', ()=>{
  popupStartRadio.style.display = 'block';
  plusDropdown.style.display = 'none';
});

setVarietyBtn.addEventListener('click', ()=>{
  popupSetVariety.style.display = 'block';
  plusDropdown.style.display = 'none';
});

settingsBtn.addEventListener('click', ()=>{
  populateSettingsModal();
  settingsModal.style.display = 'block';
  plusDropdown.style.display = 'none';
});

/* popup start button */
document.getElementById('popupStartBtn').addEventListener('click', async ()=>{
  const val = document.getElementById('popupInputStart').value.trim();
  if(val){
    popupStartRadio.style.display = 'none';
    await loadArtist(val);
    await play();
  }
});

/* variety save/close */
document.getElementById('popupVarietyClose').addEventListener('click', ()=>{
  maxSimilarPages = parseInt(document.getElementById('maxSimilarInput').value) || 250;
  maxTrackPages = parseInt(document.getElementById('maxTrackInput').value) || 2;
  popupSetVariety.style.display = 'none';
});

/* Settings modal buttons */
document.getElementById('saveSettingsBtn').addEventListener('click', ()=>{
  applySettingsFromModal();
  settingsModal.style.display = 'none';
  showToast('Settings saved.');
});

document.getElementById('closeSettingsBtn').addEventListener('click', ()=>{
  settingsModal.style.display = 'none';
});

/* Import / Export */
const importFileEl = document.getElementById('importFile');
document.getElementById('importBtn').addEventListener('click', ()=>{
  importFileEl.value = '';
  importFileEl.click();
});

importFileEl.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const obj = JSON.parse(ev.target.result);
      // apply safely
      if(obj.audioPlayerChoice) audioPlayerChoice = obj.audioPlayerChoice;
      if(obj.LASTFM_API_KEY !== undefined) LASTFM_API_KEY = obj.LASTFM_API_KEY;
      if(obj.DISCOGS_TOKEN !== undefined) DISCOGS_TOKEN = obj.DISCOGS_TOKEN;
      if(obj.SPOTIFY_CLIENT_ID !== undefined) SPOTIFY_CLIENT_ID = obj.SPOTIFY_CLIENT_ID;
      if(obj.SPOTIFY_CLIENT_SECRET !== undefined) SPOTIFY_CLIENT_SECRET = obj.SPOTIFY_CLIENT_SECRET;
      if(obj.PROXY_URL !== undefined) PROXY_URL = obj.PROXY_URL;
      if(obj.maxSimilarPages) maxSimilarPages = obj.maxSimilarPages;
      if(obj.maxTrackPages) maxTrackPages = obj.maxTrackPages;
      saveSettingsToLocalStorage();
      populateSettingsModal();
      showToast('Settings imported.');
      settingsModal.style.display = 'none';
    }catch(err){
      showToast('Import failed: invalid file');
      console.error(err);
    }
  };
  reader.readAsText(f);
});

/* Export */
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const s = {
    audioPlayerChoice,
    LASTFM_API_KEY,
    DISCOGS_TOKEN,
    SPOTIFY_CLIENT_ID,
    SPOTIFY_CLIENT_SECRET,
    PROXY_URL,
    maxSimilarPages,
    maxTrackPages
  };
  const blob = new Blob([JSON.stringify(s, null, 2)], {type:'application/json'});
  const now = new Date();
  const pad = n=> String(n).padStart(2,'0');
  const fname = `LFM-settings-${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = fname;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  showToast('Settings exported.');
});

/* Hide broken image (browser) */
const img = document.getElementById("albumImg");
img.onerror = () => img.style.display = "none";
img.onload = () => img.style.display = "block";

/* Orientation check */
function checkOrientation() {
  const overlay = document.getElementById('portraitOverlay');
  if(window.innerHeight < window.innerWidth) {
    overlay.style.display = 'flex';
  } else {
    overlay.style.display = 'none';
  }
}
checkOrientation();
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);

/* On first load: populate settings modal inputs with current values */
populateSettingsModal();

/* If you want to allow installing as PWA (Add to Home Screen) you'll need manifest + service worker.
   You said to leave it as installable from browser if possible; that requires extra files which
   are outside single-file HTML. So I'm leaving PWA manifest out per your request. */

/* Optional: expose onYouTubeIframeAPIReady globally (YT API expects this name) */
window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;

/* End of script */
</script>
</body>
</html>
