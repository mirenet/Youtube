<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Last.fm Player Styled</title>

<style>
:root {
  --bg-top: #0F0F0F;
  --bg-bottom: #000000;
  --btn-accent: #CBD868;
  --btn-muted: #B9ADA1;
  --artist-col: #959398;
  --track-col: #3E3D43;
  --bio-col: #3E3D43;
  --progress-col: #C8D86D;
}

html, body {
  overflow: hidden; /* zabrani skrol */
  height: 100%;
  margin: 0;

  background:
    url("wallpaper-1.jpg") no-repeat center center fixed,
    linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
    url("wallpaper-2.jpg") no-repeat center center fixed,
    #0F0F0F;

  background-size: cover, cover, cover, auto;
  background-attachment: fixed, fixed, fixed, scroll;
  background-position: center center, center center, center center, initial;

  font-family: Inter, "Arial", sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
}

.player {
  width: 380px;
  padding: 20px;
  padding-top: env(safe-area-inset-top, 10px);
  padding-bottom: env(safe-area-inset-bottom);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  box-shadow: 0 8px 20px rgba(0,0,0,0.6);
  background: var(--bg);
  border-radius: 12px;
  height: 100vh;

}

.top-bar {
  flex: 0 0 60px;
  position: fixed;
  top: env(safe-area-inset-top, 10px);
  width: 90%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 6px;
  padding: 0 15px;
  z-index: 100; /* dodato */
}


.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow: hidden;
  width: 100%; 
}





.icon-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--btn-muted);
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.12);
}

.plus {
  color: #000;
  font-weight: 700;
  font-size: 25px;
}

.heart {
  position: relative;
  width: 10px;
  height: 10px;
  background: black;
  transform: rotate(-45deg);
  left: 0.4px;
  top: 2px;
}

.heart:before,
.heart:after {
  content: "";
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: black;
}

.heart:before { top: -6px; left: 0; }
.heart:after  { left: 6px; top: 0; }

.album-wrap {
  position: relative;
  width: 300px;
  height: 300px;
  margin-top: 58px;
  margin-bottom: 6px;
}

.progress {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  --p: 28;
  background: conic-gradient(var(--progress-col) calc(var(--p)*1%), rgba(255,255,255,0) 0);
  transform: rotate(-90deg);
  mask: radial-gradient(farthest-side, transparent 98%, black 99%);
  -webkit-mask: radial-gradient(farthest-side, transparent 98%, black 99%);
  z-index: 1;
}

.progress {
display: none;
}

.album-img {
  position: absolute;
  width: 270px;
  height: 270px;
  border-radius: 50%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  object-fit: cover;
  object-position: center top; /* lice bliže vrhu */
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  z-index: 2;
}

.album-img[src=""],
.album-img[alt]:not([src]) {
  display: none;
}

.track-info {
  display: flex;
  flex-direction: column;
  align-items: center;  
  text-align: center;
  margin-top: -20px;
  margin-bottom: 10px;
  width: 100%;
}

.artist {
  color: #8AA7B8;
  font-weight: 700;
  font-size: 18px;
  margin-top: 15px;
  margin-bottom: 6px;
  white-space: nowrap;    
  overflow: hidden;            
  text-overflow: ellipsis;  
  max-width: 270px;        
} 

.track {
  color: #E03A44;
  font-weight: 500;
  font-size: 15px;
  margin-bottom: 3px;
  white-space: nowrap;      
  overflow: hidden;             
  text-overflow: ellipsis;  
  max-width: 270px;         
}

.bio-wrap {
  flex: 1;    /* da se siri */
  width: 90%;
  /* height: 250px; */
 /* position: relative; */
  overflow-y: auto;
  /* padding-top: 60px; */ /* visina top bara */
  padding-bottom: 100px; /* visina controls */
  position: relative;
}

.bio {
  height: 100%;
  overflow-y: auto;
  padding: 6px 8px;
  box-sizing: border-box;
  color: #9E9DA4;
  font-size: 14px;
  line-height: 1.45;
  text-align: left; 
} 


.controls {
  position: fixed;
  bottom: env(safe-area-inset-bottom, 10px);
  display: flex;
 /* flex: 0 0 70px; */  /* visina dugmica */
  gap: 18px;
  align-items: center;
  justify-content: center;
  width: 100%;
/*  margin-top: 25px; */  /* prostor do bio */
  margin-bottom: 5px;
}




.ctrl {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(0,0,0,0.5);
}
.ctrl.small {
  width: 44px;
  height: 44px;
  background: #B9ADA2;
  color: #000000;
  border: 1px solid rgba(255,255,255,0.03);
}
.ctrl.play {
  width: 60px;
  height: 60px;
  background: var(--btn-accent);
  color: #000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.app-title {
  text-align: center;
  font-weight: 700;
  font-size: 18px;
  color: var(--btn-accent);
  margin-top: 1px;
}

:root {
  --icon-scale: 0.80; 
}

.ico {
  display: inline-block;
  position: relative;
}

.ico.plus {
  width: calc(20px * var(--icon-scale));
  height: calc(4px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
}
.ico.plus::after {
  content: "";
  position: absolute;
  left: 50%;
  top: calc(-8px * var(--icon-scale));
  width: calc(4px * var(--icon-scale));
  height: calc(20px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
  transform: translateX(-50%);
}

.ico.play {
  width: 0;
  height: 0;
  border-top: calc(13px * var(--icon-scale)) solid transparent;
  border-bottom: calc(13px * var(--icon-scale)) solid transparent;
  border-left: calc(20px * var(--icon-scale)) solid #000;
  border-radius: 3px;
  transform: translateX(2px);
}

.ico.stop {
  width: calc(17px * var(--icon-scale));
  height: calc(17px * var(--icon-scale));
  background: #000;
  border-radius: 3px;
}

.ico.next {
  width: 0;
  height: 0;
  border-top: calc(10px * var(--icon-scale)) solid transparent;
  border-bottom: calc(10px * var(--icon-scale)) solid transparent;
  border-left: calc(16px * var(--icon-scale)) solid #000;
  border-radius: 3px;
  transform: translateX(-2px);
}
.ico.next::after {
  content: "";
  position: absolute;
  top: calc(-9px * var(--icon-scale));
  right: calc(-6px * var(--icon-scale));
  width: calc(4px * var(--icon-scale));
  height: calc(18px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
}

.popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80%;
  max-width: 400px;
  background: #1a1a1c;
  border-radius: 12px;
  padding: 20px;
  z-index: 100;
}

.popup input {
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  background: transparent;
  color: inherit;
  margin-bottom: 12px;
}

.popup button {
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  border: none;
  background: var(--btn-accent);
  color: #000;
  cursor: pointer;
}

.dropdown {
  position: absolute;
  top: 60px;
  left: 20px;
  display: none;
  flex-direction: column;
  background: #1a1a1c;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
z-index: 101; /* dodato */
}

.dropdown button {
  width: 100%;
  padding: 8px 12px;
  border: none;
  background: none;
  color: #fff;
  text-align: left;
  cursor: pointer;
}

.dropdown button:hover {
  background: var(--btn-accent);
  color: #000;
}

.toast {
visibility: hidden;
min-width: 160px;
max-width: 320px;
background-color: rgba(83,82,85,0.95); /* tvoja boja sa blago providnom pozadinom */
color: #fff;
text-align: center;
border-radius: 24px;
padding: 14px 24px;
position: fixed;
bottom: 80px;
left: 50%;
transform: translateX(-50%);
font-size: 15px;
font-family: sans-serif;
box-shadow: 0 2px 10px rgba(0,0,0,0.3);
z-index: 9999;
opacity: 0;
pointer-events: none;
transition: opacity 0.25s ease-in-out, bottom 0.25s ease-in-out;
}

.toast.show {
visibility: visible;
opacity: 1;
bottom: 100px; /* blagi “slide-up” efekat */
}

/* Vrati korisnika u portrait mode*/
#portraitOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000; /* potpuno crno, neprozirno */
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-size: 18px;
  font-family: sans-serif;
  z-index: 9999;
  padding: 20px;
  box-sizing: border-box;
  display: none; /* default hidden */
}



</style>
</head>

<body>
<div class="player">
  <div class="top-bar">
    <div class="icon-circle" id="plusBtn"><span class="ico plus" aria-hidden="true"></span></div>
    <h1 class="app-title">Last.Fm</h1>
    <div class="icon-circle" id="heartBtn"><div class="heart" aria-hidden="true"></div></div>
  </div>

  <!-- dropdown je apsolutno pozicioniran unutar .player -->
  <div class="dropdown" id="plusDropdown" aria-hidden="true">
    <button id="startRadioBtn">Start Radio</button>
    <button id="setVarietyBtn">Set Variety</button>
  </div>

  <!-- content zauzima prostor između top-bar i controls -->
  <div class="content">
    <div class="timer" id="status"></div>
    <div class="debug" id="debugArea"></div>

    <div class="album-wrap">
      <div class="progress" style="--p:0;"></div>
      <img class="album-img" src="" alt="Artist photo" id="albumImg">
    </div>

    <div class="track-info">
      <div class="artist" id="artistName">‎ </div>
      <div class="track" id="trackName">‎ </div>
    </div>

    <div class="bio-wrap">
      <div class="bio" id="bio">‎ </div>
    </div>
  </div>

  <!-- controls uvek na dnu -->
  <div class="controls">
    <div class="ctrl small" id="stopBtn"><span class="ico stop" aria-hidden="true"></span></div>
    <div class="ctrl play" id="playBtn"><span class="ico play" aria-hidden="true"></span></div>
    <div class="ctrl small" id="nextBtn"><span class="ico next" aria-hidden="true"></span></div>
  </div>

  <div id="popupStartRadio" class="popup">
    <input type="text" id="popupInputStart" placeholder="Enter artist name">
    <button id="popupStartBtn">Start</button>
  </div>

  <div id="popupSetVariety" class="popup">
    <label>Max Similar Artists:</label>
    <input type="number" id="maxSimilarInput" value="250" min="1" max="2000">
    <label>Max Track Pages:</label>
    <input type="number" id="maxTrackInput" value="2" min="1" max="50">
    <button id="popupVarietyClose">Close</button>
  </div>
</div>

<!-- SKRIVENI YT PLAYER (u potpunosti sakriven) -->
<div id="ytPlayerContainer" style="position:fixed; width:0; height:0; overflow:hidden; left:-9999px; top:-9999px; opacity:0; pointer-events:none;">
  <div id="ytPlayer"></div>
</div>

<div id="toast" class="toast"></div>

<div id="portraitOverlay">
  This app work only in portrait mode!<br>Please, rotate your device!
</div>




<script>
const PROXY_URL = 'https://mire021.mireinternet.workers.dev?url=';
let baseArtist = '', currentArtistOnScreen = '', currentVideoUrl = '', currentVideoUrlArtist = '', currentVideoUrlTrack = '', preloadCache = null;
const EMPTY_VIDEO_URL = "https://www.youtube.com/watch?v=tbnLqRW9Ef0";
let maxSimilarPages = 250, maxTrackPages = 2;

// --- Last.fm API key ---
const LASTFM_API_KEY = 'e5147a4d5b2018c3832b146b74b61061'; // ubaci svoj Last.fm API key

// --- Helper functions ---
function debug(msg) {}

function normalizeArtistForDisplay(a){ return a.replace(/\+/g,' '); }
function normalizeArtistForSearch(a){ return a.replace(/ /g,'+'); }

function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }






// --- Last.fm - Top Tracks
async function getRandomTopTrack(artist){
    try {
        // 1. Prvi poziv: stranica 1, saznajemo koliko ukupno stranica ima
        const urlPage1 = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artist)}&api_key=${LASTFM_API_KEY}&format=json&limit=50&page=1`;
        const resPage1 = await fetch(urlPage1);
        const dataPage1 = await resPage1.json();

        // koliko ukupno stranica ima
        const totalPages = parseInt(dataPage1.toptracks['@attr'].totalPages, 10) || 1;

        // Ograničavamo na maxTrackPages iz popup-a
        const maxPages = Math.min(totalPages, maxTrackPages);

        // Pauza 1 sekunda prije sledećeg poziva
        await sleep(1000);

        // 2. Random biramo stranicu između 1 i maxPages
        const page = Math.floor(Math.random() * maxPages) + 1;

        // 3. Poziv za tu stranicu
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artist)}&api_key=${LASTFM_API_KEY}&format=json&limit=50&page=${page}`;
        const res = await fetch(url);
        const data = await res.json();

        const tracks = data.toptracks && data.toptracks.track ? data.toptracks.track.map(t => t.name) : [];
        if(tracks.length === 0) return 'Demo Track';

        // 4. Random pesma sa te stranice
        return tracks[Math.floor(Math.random() * tracks.length)];

    } catch(e) {
        console.error("getRandomTopTrack failed", e);
        return 'Demo Track';
    }
}







// --- Last.fm - Similar Artists
async function getRandomSimilarArtist(){
    try{
        if(!baseArtist) return '';
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=${encodeURIComponent(baseArtist)}&api_key=${LASTFM_API_KEY}&format=json&limit=${maxSimilarPages}`;
        const res = await fetch(url);
        const data = await res.json();
        const artists = data.similarartists && data.similarartists.artist ? data.similarartists.artist.map(a=>a.name) : [];
        if(artists.length) return artists[Math.floor(Math.random()*artists.length)];
        return baseArtist;
    } catch(e){ return baseArtist; }
}










// --- Last.fm Bio + Discogs/Spotify Images
async function getArtistImagesAndBio(artist) {
    const discogsToken = "MrikosMJLcAbEUiXPnwsstSRPzQvnAEOHDEcoTaM";

    try {
        // --- Last.fm bio + dodatni podaci ---
        const bioAndInfo = await fetchLastFmBioShort(artist);

      // --- Spotify slike ---
        const spotifyImages = await fetchSpotifyImages(artist);

        // --- Discogs slike ---
        const discogsImages = await fetchDiscogsImage(artist, discogsToken);

        // --- Spajamo slike: Spotify prva, Discogs posle ---
        const images = [...spotifyImages, ...discogsImages.filter(img => !spotifyImages.includes(img))];

        return { bio: bioAndInfo, images: images.length ? images : [] };

    } catch (e) {
        console.error(e);
        return { bio: "Biography not found.", images: [] };
    }






    // --- Last.fm Biography  ---
    async function fetchLastFmBioShort(artistName) {
        try {
            const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${LASTFM_API_KEY}&format=json`;
            const res = await fetch(url);
            const data = await res.json();

            let bio = data.artist?.bio?.content?.trim() || "Biography not found.";

            // --- Izvuci link iz bio i ukloni originalni <a> ---
            let readMoreLink = "";
            const match = bio.match(/<a href="([^"]+)">.*?<\/a>/i);
          // if (match) { readMoreLink = `<br><br>Read more on Last.fm: [${match[1]}]`;
            if (match) { readMoreLink = '';
            bio = bio.replace(/<a href="[^"]+">.*?<\/a>/i, "");
            }

            // Dodatne informacije
            const stats = data.artist?.stats || {};
            const tags = data.artist?.tags?.tag?.map(t => t.name).join(", ") || "";
            const similar = data.artist?.similar?.artist?.map(a => a.name).join(", ") || "";

            let extra = "";
            if (stats.listeners) extra += `<br>Listeners: ${stats.listeners}`;
            if (stats.playcount) extra += `<br>Playcount: ${stats.playcount}`;
            if (tags) extra += `<br>Genre: ${tags}`;
            if (similar) extra += `<br>Similar Artists: ${similar}`;

            if (extra) extra = `<br>${extra}`;

            return `${bio}${extra}${readMoreLink}`;
        } catch (e) {
            console.error("Last.fm bio fetch failed", e);
            return "Biography not found.";
        }
    }








// --- Spotify Images ---
async function fetchSpotifyImages(artistName, maxImages = 10, enabled = true) {
    if (!enabled) return []; 
    try {
        const SPOTIFY_CLIENT_ID = "d7308ace981d46d385bab314f8ef0546";
        const SPOTIFY_CLIENT_SECRET = "707748e12786459dba6982c82bdd8d51";

        // Dobij token
        const resp = await fetch("https://accounts.spotify.com/api/token", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Authorization": "Basic " + btoa(SPOTIFY_CLIENT_ID + ":" + SPOTIFY_CLIENT_SECRET)
            },
            body: "grant_type=client_credentials"
        });
        const data = await resp.json();
        const token = data.access_token;

        // Pretraga izvođača
        const searchRes = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(artistName)}&type=artist&limit=50`, {
            headers: { "Authorization": `Bearer ${token}` }
        });
        const searchData = await searchRes.json();
        const artist = searchData.artists.items[0];
        if (!artist || !artist.images) return [];

        // Biranje slike po prioritetu: 640 -> 320 -> 160
        const preferredSizes = [640, 320, 160];
        let selected = [];

        for (let size of preferredSizes) {
            selected = artist.images
                .filter(img => img.width === size && img.height === size)
                .slice(0, maxImages)
                .map(img => img.url);
            if (selected.length > 0) break; // ako ima slike u toj veličini, ne traži manju
        }

        // fallback: ako nema nijedne u preferiranim veličinama, uzmi najveću dostupnu
        if (selected.length === 0 && artist.images.length > 0) {
            const largest = artist.images.sort((a,b) => (b.width*b.height)-(a.width*a.height))[0];
            selected = [largest.url];
        }

        return selected;
    } catch (e) {
        console.warn("Spotify image fetch failed", e);
        return [];
    }
}










   
// ---Discogs Images ---
async function fetchDiscogsImage(artistName, token, minWidth = 1500, minHeight = 1500, maxImages = 5, randomize = true, enabled = true) { if (!enabled) return []; 

    try {
        // 1. Search artist
        const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(artistName)}&type=artist&token=${token}`;
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (!searchData.results || searchData.results.length === 0) return [];

        const firstResult = searchData.results[0];
        const coverImage = firstResult.cover_image || null;
        const artistId = firstResult.id;

        await sleep(1000); // razmak 1s

        // 2. Fetch artist details
        const artistUrl = `https://api.discogs.com/artists/${artistId}?token=${token}`;
        const artistRes = await fetch(artistUrl);
        const artistData = await artistRes.json();

        if (!artistData.images || artistData.images.length === 0) {
            return coverImage ? [coverImage] : [];
        }

        // 3. Pripremi sve slike (cover + primary + secondary)
        let allImages = [];

        // dodaj cover prvo, ako postoji
        if (coverImage) {
            allImages.push({ uri: coverImage, width: 0, height: 0, area: 0, type: "cover" });
        }

        // dodaj ostale slike iz artistData.images
        artistData.images.forEach(img => {
            allImages.push({
                uri: img.uri,
                width: img.width,
                height: img.height,
                area: img.width * img.height,
                type: img.type
            });
        });

        // ukloni eventualni duplikat covera
        if (coverImage) {
            allImages = allImages.filter((img, idx, arr) => !(img.uri === coverImage && idx !== arr.findIndex(i => i.uri === coverImage)));
        }

        // 4. Filtriraj slike po minimalnoj veličini
        let candidates = allImages.filter(img => img.width >= minWidth && img.height >= minHeight);

        // 5. Ako nema kandidata, uzmi step-down (najveće preostale slike)
        if (candidates.length === 0) {
            candidates = [...allImages].sort((a, b) => b.area - a.area);
        }

        // 6. Randomizacija među kandidatima
        let selected;
        if (randomize) {
            selected = [];
            let pool = [...candidates];
            while (pool.length > 0 && selected.length < maxImages) {
                const idx = Math.floor(Math.random() * pool.length);
                selected.push(pool[idx]);
                pool.splice(idx, 1);
            }
        } else {
            selected = candidates.slice(0, maxImages);
        }

        // 7. Fallback: dodaj cover ako još nije u selected i ima mesta
        if (coverImage && !selected.find(img => img.uri === coverImage)) {
            if (selected.length < maxImages) {
                selected.push({ uri: coverImage, width: 0, height: 0, area: 0, type: "cover" });
            }
        }

        // 8. Sortiranje po površini za prikaz
        selected.sort((a, b) => b.area - a.area);

        // 9. Vraća samo URI-jeve
        return selected.map(img => img.uri);

    } catch (e) {
        console.error("Discogs image fetch failed", e);
        return [];
    }
}

}













// --- Carousel ---
let carouselInterval = null;
function renderCarousel(images){
    const imgEl = document.getElementById('albumImg');
    if(!images.length){ imgEl.src=''; return; }
    let idx = 0; imgEl.src = images[idx];
    if(carouselInterval) clearInterval(carouselInterval);
    carouselInterval = setInterval(()=>{ idx=(idx+1)%images.length; imgEl.src=images[idx]; }, 10000);
}

// --- YouTube search via proxy ---
const INV_INSTANCES = [
  "https://yewtu.be",
  "https://invidious.snopyta.org",
  "https://vid.puffyan.us",
  "https://invidious.kavin.rocks",
  "https://invidious.tiekoetter.com"
];


// --- Toast helper ---
function showToast(msg, duration=3000){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(()=> t.classList.remove('show'), duration);
}


// --- Advanced YouTube search + fallback Invidious + toast ---
async function searchYouTubeHtml(query){
    const BLACKLIST = ["remix","extended","album","live","mix","cover","tribute","instrumental","karaoke"];

    function containsBlacklist(str){ return BLACKLIST.some(b=>str.toLowerCase().includes(b)); }

    async function searchYTHTML(q){
        try {
            const url = `https://www.youtube.com/results?search_query=${encodeURIComponent(q)}`;
            const html = await fetch(PROXY_URL + encodeURIComponent(url)).then(r=>r.text());
            const match = html.match(/var ytInitialData = (.*?);\s*<\/script>/);
            if(!match) throw new Error("ytInitialData not found");
            const data = JSON.parse(match[1]);
            const contents = data.contents
              .twoColumnSearchResultsRenderer.primaryContents
              .sectionListRenderer.contents[0].itemSectionRenderer.contents;
            const videos = contents.filter(x=>x.videoRenderer).map(x=>x.videoRenderer);
            if(!videos.length) throw new Error("No videos found");

            const queryHasBlacklist = containsBlacklist(q);
            const artist = q.split('-')[0].trim().toLowerCase();
            const qNoDash = q.replace(/-/g,'').replace(/\s+/g,' ').trim();

            // --- Fallback logika ---
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase() === q.toLowerCase()) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase().replace(/-/g,'').includes(qNoDash.toLowerCase())) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase().includes(q.toLowerCase())) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(title.toLowerCase().includes(artist)) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            return "https://www.youtube.com/watch?v="+videos[0].videoId;
        } catch(e) {
            throw new Error("YT HTML failed: "+e.message);
        }
    }

    async function searchInvidious(q){
        for(const baseUrl of INV_INSTANCES){
            try{
                const searchUrl = `${baseUrl}/search?q=${encodeURIComponent(q)}`;
                const html = await fetch(PROXY_URL + encodeURIComponent(searchUrl)).then(r=>r.text());
                const doc = new DOMParser().parseFromString(html,'text/html');
                const links = [...doc.querySelectorAll('a[href*="/watch?v="]')];
                const queryHasBlacklist = containsBlacklist(q);
                for(const link of links){
                    const title = link.getAttribute('title') || link.textContent;
                    if(!title) continue;
                    if(!queryHasBlacklist && containsBlacklist(title)) continue;
                    if(title.toLowerCase().includes(q.toLowerCase())){
                        const href = link.getAttribute('href');
                        return href.startsWith('http') ? href : baseUrl + href;
                    }
                }
                if(links.length){
                    const href = links[0].getAttribute('href');
                    return href.startsWith('http') ? href : baseUrl + href;
                }
            }catch(e){ continue; }
        }
        throw new Error("Invidious failed");
    }

    // --- glavna logika ---
    try{
        const url = await searchYTHTML(query);
        return url;
    }catch(e){
        console.warn("YT HTML failed, switching to Invidious:", e);
        showToast("YT HTML search failed, switching to Invidious...");
        try{
            const url = await searchInvidious(query);
            showToast("Invidious search succeeded.");
            return url;
        }catch(e2){
            showToast("Neither YT HTML nor Invidious worked!");
            throw new Error("No source available");
        }
    }
}















function buildIntentUrl(youtubeUrl){
  if(!youtubeUrl) return '';
  const clean = youtubeUrl.replace(/^https?:\/\//,'');
  return `intent://${clean}#Intent;package=org.schabi.newpipe;scheme=https;end`;
}

/* ---------------------------
   YOUTUBE IFRAME PLAYER CODE
   - Sakriveni iframe
   - Kada se video zavrsi -> automatski poziva next()
   - play()/next()/stopVideo() su prilagodjene da koriste ovaj player
   --------------------------- */

let ytPlayer = null;
let ytApiLoaded = false;

// Ucitaj YouTube IFrame API
function loadYouTubeIframeAPI(){
  if(window.YT && YT.Player){
    ytApiLoaded = true;
    createYTPlayerIfNeeded();
    return;
  }
  if(document.getElementById('youtube-iframe-api')) return;
  const tag = document.createElement('script');
  tag.id = 'youtube-iframe-api';
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
  // global callback onYouTubeIframeAPIReady() is called by the API
}

// This function is called by the YT API when ready
function onYouTubeIframeAPIReady(){
  ytApiLoaded = true;
  createYTPlayerIfNeeded();
}

function createYTPlayerIfNeeded(){
  if(!ytApiLoaded) return;
  if(ytPlayer) return;
  // create player in the hidden container
  ytPlayer = new YT.Player('ytPlayer', {
    height: '0',
    width: '0',
    playerVars: {
      autoplay: 0,
      controls: 0,
      modestbranding: 1,
      rel: 0,
      playsinline: 1,
      disablekb: 1,
      iv_load_policy: 3,
      fs: 0
    },
    events: {
      'onReady': (e) => {
        // ready
      },
      'onStateChange': onYTStateChange
    }
  });
}

// Extract video ID from YouTube URL (many formats)
function getYouTubeID(url){
  if(!url) return null;
  // examples: https://www.youtube.com/watch?v=VIDEOID, https://youtu.be/VIDEOID, https://www.youtube.com/embed/VIDEOID
  const patterns = [
    /(?:youtu\.be\/)([A-Za-z0-9_\-]{11})/,
    /(?:v=)([A-Za-z0-9_\-]{11})/,
    /(?:embed\/)([A-Za-z0-9_\-]{11})/,
    /(?:\/v\/)([A-Za-z0-9_\-]{11})/,
    /([A-Za-z0-9_\-]{11})$/ // fallback: last 11 chars
  ];
  for(const p of patterns){
    const m = url.match(p);
    if(m && m[1]) return m[1];
  }
  return null;
}

function onYTStateChange(event){
  // 0 === ended, 1 === playing, 2 === paused, 3 === buffering
  try{
    if(event.data === YT.PlayerState.ENDED){
      // automatski "stisni" next dugme (poziva next())
      try{
        next();
      }catch(e){
        console.warn("Auto-next failed:", e);
        const nb = document.getElementById('nextBtn');
        if(nb) nb.click();
      }
    } else if(event.data === YT.PlayerState.PLAYING){
      // update media session state
      try{ if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing'; }catch(e){}
    } else if(event.data === YT.PlayerState.PAUSED){
      try{ if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused'; }catch(e){}
    }
  }catch(e){
    console.warn('onYTStateChange error', e);
  }
}

/**
 * Cue and play a youtube URL in hidden player.
 * If player not loaded yet, load API and wait.
 */
function cueAndPlayUrl(youtubeUrl, autoplay = true){
  if(!youtubeUrl) return;
  const vid = getYouTubeID(youtubeUrl);
  if(!vid) {
    console.warn('Invalid YouTube URL:', youtubeUrl);
    return;
  }
  loadYouTubeIframeAPI();
  const tryLoad = () => {
    if(ytPlayer && typeof ytPlayer.loadVideoById === 'function'){
      try {
        // load and optionally play
        ytPlayer.loadVideoById(vid);
        if(autoplay){
          // ensure play attempt after a tiny delay so mobile browsers accept user gesture when originating from click
          setTimeout(()=>{ try{ ytPlayer.playVideo(); }catch(e){ console.warn("playVideo failed", e); } }, 150);
        }
      } catch(e) {
        console.warn("Couldn't load video into ytPlayer", e);
      }
      return true;
    }
    return false;
  };

  if(!tryLoad()){
    // Wait until player is created
    let attempts = 0;
    const int = setInterval(()=> {
      attempts++;
      if(tryLoad() || attempts > 50){
        clearInterval(int);
      }
    }, 200);
  }
}

/* ---------------------------
   MEDIA SESSION: metadata + handlers
   - ovo pomaže da sistem tretira reproduce kao media playback
   - ažuriraj metadata svaki put kad se promeni pesma
   --------------------------- */

function updateMediaSessionMetadata(artist, track, imageUrl){
  try{
    if(!('mediaSession' in navigator)) return;
    const artwork = [];
    if(imageUrl){
      // push several sizes fallback (device may pick best)
      artwork.push({ src: imageUrl,   sizes: '512x512', type: 'image/jpeg' });
      artwork.push({ src: imageUrl,   sizes: '256x256', type: 'image/jpeg' });
      artwork.push({ src: imageUrl,   sizes: '96x96', type: 'image/jpeg' });
    }
    navigator.mediaSession.metadata = new MediaMetadata({
      title: track || '',
      artist: artist || '',
      album: '',
      artwork: artwork
    });
  }catch(e){ console.warn("updateMediaSessionMetadata failed", e); }
}

// Media Session action handlers
function setupMediaSessionHandlers(){
  if(!('mediaSession' in navigator)) return;
  try{
    navigator.mediaSession.setActionHandler('play', async ()=> {
      try {
        // resume hidden player or cue & play currentVideoUrl
        if(ytPlayer && typeof ytPlayer.playVideo === 'function'){
          try{ ytPlayer.playVideo(); }catch(e){ console.warn(e); }
        } else {
          if(currentVideoUrl) cueAndPlayUrl(currentVideoUrl, true);
        }
        navigator.mediaSession.playbackState = 'playing';
      } catch(e){ console.warn('mediaSession play handler', e); }
    });
    navigator.mediaSession.setActionHandler('pause', ()=> {
      try{
        if(ytPlayer && typeof ytPlayer.pauseVideo === 'function') ytPlayer.pauseVideo();
        navigator.mediaSession.playbackState = 'paused';
      }catch(e){ console.warn(e); }
    });
    navigator.mediaSession.setActionHandler('stop', ()=> {
      try{
        stopVideo();
        navigator.mediaSession.playbackState = 'none';
      }catch(e){ console.warn(e); }
    });
    navigator.mediaSession.setActionHandler('nexttrack', ()=> {
      try{ next(); }catch(e){ console.warn(e); }
    });
    // optional: previous track -> we don't have prev logic; map to stop
    navigator.mediaSession.setActionHandler('previoustrack', ()=> {
      try{ stopVideo(); }catch(e){ console.warn(e); }
    });
  }catch(e){ console.warn('setupMediaSessionHandlers failed', e); }
}

// initialize handlers on load
setupMediaSessionHandlers();

/* ---------------------------
   KRAJ MEDIA SESSION
   --------------------------- */



// --- Preload ---
async function preloadNextTrack(){
    if(!baseArtist) return;

    const pickArtist = await getRandomSimilarArtist();
    await sleep(1000); // razmak 1s

    const {images, bio} = await getArtistImagesAndBio(pickArtist);
    await sleep(1000); // razmak 1s

    const pickTrack = await getRandomTopTrack(pickArtist);

    await sleep(1000); // razmak 1s
    
    const youtubeUrl = await searchYouTubeHtml(`${normalizeArtistForSearch(pickArtist)} - ${pickTrack}`);
    preloadCache = { artist: pickArtist, track: pickTrack, images, bio, youtubeUrl };
}

async function loadArtist(artist) {
    baseArtist = artist;
    currentArtistOnScreen = artist;

    // --- Prikaži Loading u naslovu ---
    const appTitle = document.querySelector('.app-title');
    const originalTitle = appTitle.textContent;
    appTitle.textContent = 'Loading...';

    try {
        // 1. Bio + slike
        const { bio, images } = await getArtistImagesAndBio(artist);
        await sleep(1000);

        // 2. Top track
        const pickTrack = await getRandomTopTrack(artist);
        await sleep(1000);

        // 3. YouTube link
        const youtubeUrl = await searchYouTubeHtml(`${normalizeArtistForSearch(artist)} - ${pickTrack}`);

        // 4. Prikaži sve odjednom
        document.getElementById('bio').innerHTML = bio.replace(/\n/g, '<br>');
        renderCarousel(images);
        document.getElementById('artistName').textContent = normalizeArtistForDisplay(artist);
        document.getElementById('trackName').textContent = pickTrack;

        currentVideoUrl = youtubeUrl;
        currentVideoUrlArtist = artist;
        currentVideoUrlTrack = pickTrack;

        // update media session metadata (use first image if available)
        const artwork = (images && images.length) ? images[0] : null;
        updateMediaSessionMetadata(artist, pickTrack, artwork);
        
        preloadNextTrack();
    } catch (e) {
        console.error("loadArtist failed", e);
        document.getElementById('bio').textContent = "Error loading artist.";
    } finally {
        // --- Vrati originalni naslov ---
        appTitle.textContent = originalTitle;
    }
}



// --- Play Video ---
async function play(){
    if(!currentVideoUrl) return;
    // umesto intent u NewPipe - koristimo skriveni embed
    cueAndPlayUrl(currentVideoUrl, true);
    // update media session state to playing (will be adjusted by onStateChange)
    try{ if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing'; }catch(e){}
   //  preloadNextTrack();
}



// ---- Next Video ----
async function next(){
    if(preloadCache){
        const {artist, track, images, bio, youtubeUrl} = preloadCache;
        currentArtistOnScreen = artist;
        document.getElementById('artistName').textContent = normalizeArtistForDisplay(artist);
        document.getElementById('trackName').textContent = track;
        //document.getElementById('bio').textContent= bio;

        document.getElementById('bio').innerHTML = bio.replace(/\n/g, '<br>');

        renderCarousel(images);
        currentVideoUrl = youtubeUrl;
        currentVideoUrlArtist = artist;
        currentVideoUrlTrack = track;

        // update media session metadata (use first image if available)
        const artwork = (images && images.length) ? images[0] : null;
        updateMediaSessionMetadata(artist, track, artwork);

        // umesto intent navigacije: loadamo u skriveni player i reprodukujemo
        cueAndPlayUrl(youtubeUrl, true);

        // pripremi sledeci
        preloadNextTrack();
    }
}

//---- Stop Video ----
function stopVideo(){
    // umesto da otvaramo NewPipe intent, zaustavimo skriveni plejer
    try{
      if(ytPlayer && typeof ytPlayer.stopVideo === 'function'){
        ytPlayer.stopVideo();
      }
    }catch(e){ console.warn(e); }
    // kao fallback, postavimo trenutni url na EMPTY (ne otvaramo novi intent)
    currentVideoUrl = EMPTY_VIDEO_URL;
    try{ if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'none'; }catch(e){}
}

// --- Event listeners ---
document.getElementById('playBtn').addEventListener('click', async (e)=> {
  // korisnicki click -> safe za autoplay na vecini browsera
  await play();
});
document.getElementById('nextBtn').addEventListener('click', async ()=> {
  await next();
});
document.getElementById('stopBtn').addEventListener('click', stopVideo);

const plusBtn = document.getElementById('plusBtn');
const plusDropdown = document.getElementById('plusDropdown');
plusBtn.addEventListener('click', ()=>{
  plusDropdown.style.display = plusDropdown.style.display==='flex' ? 'none' : 'flex';
});

const startRadioBtn = document.getElementById('startRadioBtn');
const setVarietyBtn = document.getElementById('setVarietyBtn');
const popupStartRadio = document.getElementById('popupStartRadio');
const popupSetVariety = document.getElementById('popupSetVariety');

startRadioBtn.addEventListener('click', ()=>{
  popupStartRadio.style.display = 'block';
  plusDropdown.style.display = 'none';
});

setVarietyBtn.addEventListener('click', ()=>{
  popupSetVariety.style.display = 'block';
  plusDropdown.style.display = 'none';
});

document.getElementById('popupStartBtn').addEventListener('click', async ()=>{
  const val = document.getElementById('popupInputStart').value.trim();
  if(val){
    popupStartRadio.style.display = 'none';
    await loadArtist(val);
    await play();
  }
});

document.getElementById('popupVarietyClose').addEventListener('click', ()=>{
  maxSimilarPages = parseInt(document.getElementById('maxSimilarInput').value) || 250;
  maxTrackPages = parseInt(document.getElementById('maxTrackInput').value) || 2;
  popupSetVariety.style.display = 'none';
});

// Hide broken image (browser)
const img = document.getElementById("albumImg");
img.onerror = () => img.style.display = "none";
img.onload = () => img.style.display = "block";



// ----Vrati korisnika u portrait mode
function checkOrientation() {
  const overlay = document.getElementById('portraitOverlay');
  if(window.innerHeight < window.innerWidth) {
    // landscape
    overlay.style.display = 'flex';
  } else {
    // portrait
    overlay.style.display = 'none';
  }
}

// inicijalna provera
checkOrientation();

// osluškuj promene orijentacije / resize
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);

// Re-setup media session handlers if page regains focus (optional improvement)
window.addEventListener('visibilitychange', () => {
  if(document.visibilityState === 'visible') {
    setupMediaSessionHandlers();
  }
});

</script>
</body>
</html>
