<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Last.fm Player Styled</title>

<style>
:root {
  --bg-top: #0F0F0F;
  --bg-bottom: #000000;
  --btn-accent: #CBD868;
  --btn-muted: #B9ADA1;
  --artist-col: #959398;
  --track-col: #3E3D43;
  --bio-col: #3E3D43;
  --progress-col: #C8D86D;
}

html, body {
  overflow: hidden; /* zabrani skrol */
  height: 100%;
  margin: 0;

  background:
    url("wallpaper-1.jpg") no-repeat center center fixed,
    linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
    url("wallpaper-2.jpg") no-repeat center center fixed,
    #0F0F0F;

  background-size: cover, cover, cover, auto;
  background-attachment: fixed, fixed, fixed, scroll;
  background-position: center center, center center, center center, initial;

  font-family: Inter, "Arial", sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
}

.player {
  width: 380px;
  padding: 20px;
  padding-top: env(safe-area-inset-top, 10px);
  padding-bottom: env(safe-area-inset-bottom);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  box-shadow: 0 8px 20px rgba(0,0,0,0.6);
  background: var(--bg);
  border-radius: 12px;
  height: 100vh;

}

.top-bar {
  flex: 0 0 60px;
  position: fixed;
  top: env(safe-area-inset-top, 10px);
  width: 90%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 6px;
  padding: 0 15px;
  z-index: 100; /* dodato */
}


.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow: hidden;
  width: 100%; 
}





.icon-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--btn-muted);
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.12);
}

.plus {
  color: #000;
  font-weight: 700;
  font-size: 25px;
}

.heart {
  position: relative;
  width: 10px;
  height: 10px;
  background: black;
  transform: rotate(-45deg);
  left: 0.4px;
  top: 2px;
}

.heart:before,
.heart:after {
  content: "";
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: black;
}

.heart:before { top: -6px; left: 0; }
.heart:after  { left: 6px; top: 0; }

.album-wrap {
  position: relative;
  width: 300px;
  height: 300px;
  margin-top: 58px;
  margin-bottom: 6px;
}

.progress {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  --p: 28;
  background: conic-gradient(var(--progress-col) calc(var(--p)*1%), rgba(255,255,255,0) 0);
  transform: rotate(-90deg);
  mask: radial-gradient(farthest-side, transparent 98%, black 99%);
  -webkit-mask: radial-gradient(farthest-side, transparent 98%, black 99%);
  z-index: 1;
}

.progress {
display: none;
}

.album-img {
  position: absolute;
  width: 270px;
  height: 270px;
  border-radius: 50%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  object-fit: cover;
  object-position: center top; /* lice bliže vrhu */
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  z-index: 2;
}

.album-img[src=""],
.album-img[alt]:not([src]) {
  display: none;
}

.track-info {
  display: flex;
  flex-direction: column;
  align-items: center;  
  text-align: center;
  margin-top: -20px;
  margin-bottom: 10px;
  width: 100%;
}

.artist {
  color: #8AA7B8;
  font-weight: 700;
  font-size: 18px;
  margin-top: 15px;
  margin-bottom: 6px;
  white-space: nowrap;    
  overflow: hidden;            
  text-overflow: ellipsis;  
  max-width: 270px;        
} 

.track {
  color: #E03A44;
  font-weight: 500;
  font-size: 15px;
  margin-bottom: 3px;
  white-space: nowrap;      
  overflow: hidden;             
  text-overflow: ellipsis;  
  max-width: 270px;         
}

.bio-wrap {
  flex: 1;    /* da se siri */
  width: 90%;
  /* height: 250px; */
 /* position: relative; */
  overflow-y: auto;
  /* padding-top: 60px; */ /* visina top bara */
  padding-bottom: 100px; /* visina controls */
  position: relative;
}

.bio {
  height: 100%;
  overflow-y: auto;
  padding: 6px 8px;
  box-sizing: border-box;
  color: #9E9DA4;
  font-size: 14px;
  line-height: 1.45;
  text-align: left; 
} 


.controls {
  position: fixed;
  bottom: env(safe-area-inset-bottom, 10px);
  display: flex;
 /* flex: 0 0 70px; */  /* visina dugmica */
  gap: 18px;
  align-items: center;
  justify-content: center;
  width: 100%;
/*  margin-top: 25px; */  /* prostor do bio */
  margin-bottom: 5px;
}




.ctrl {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(0,0,0,0.5);
}
.ctrl.small {
  width: 44px;
  height: 44px;
  background: #B9ADA2;
  color: #000000;
  border: 1px solid rgba(255,255,255,0.03);
}
.ctrl.play {
  width: 60px;
  height: 60px;
  background: var(--btn-accent);
  color: #000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.app-title {
  text-align: center;
  font-weight: 700;
  font-size: 18px;
  color: var(--btn-accent);
  margin-top: 1px;
}

:root {
  --icon-scale: 0.80; 
}

.ico {
  display: inline-block;
  position: relative;
}

.ico.plus {
  width: calc(20px * var(--icon-scale));
  height: calc(4px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
}
.ico.plus::after {
  content: "";
  position: absolute;
  left: 50%;
  top: calc(-8px * var(--icon-scale));
  width: calc(4px * var(--icon-scale));
  height: calc(20px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
  transform: translateX(-50%);
}

.ico.play {
  width: 0;
  height: 0;
  border-top: calc(13px * var(--icon-scale)) solid transparent;
  border-bottom: calc(13px * var(--icon-scale)) solid transparent;
  border-left: calc(20px * var(--icon-scale)) solid #000;
  border-radius: 3px;
  transform: translateX(2px);
}

.ico.stop {
  width: calc(17px * var(--icon-scale));
  height: calc(17px * var(--icon-scale));
  background: #000;
  border-radius: 3px;
}

.ico.next {
  width: 0;
  height: 0;
  border-top: calc(10px * var(--icon-scale)) solid transparent;
  border-bottom: calc(10px * var(--icon-scale)) solid transparent;
  border-left: calc(16px * var(--icon-scale)) solid #000;
  border-radius: 3px;
  transform: translateX(-2px);
}
.ico.next::after {
  content: "";
  position: absolute;
  top: calc(-9px * var(--icon-scale));
  right: calc(-6px * var(--icon-scale));
  width: calc(4px * var(--icon-scale));
  height: calc(18px * var(--icon-scale));
  background: #000;
  border-radius: 2px;
}

.popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80%;
  max-width: 400px;
  background: #1a1a1c;
  border-radius: 12px;
  padding: 20px;
  z-index: 100;
}

.popup input {
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  background: transparent;
  color: inherit;
  margin-bottom: 12px;
}

.popup button {
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  border: none;
  background: var(--btn-accent);
  color: #000;
  cursor: pointer;
}

.dropdown {
  position: absolute;
  top: 60px;
  left: 20px;
  display: none;
  flex-direction: column;
  background: #1a1a1c;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
z-index: 101; /* dodato */
}

.dropdown button {
  width: 100%;
  padding: 8px 12px;
  border: none;
  background: none;
  color: #fff;
  text-align: left;
  cursor: pointer;
}

.dropdown button:hover {
  background: var(--btn-accent);
  color: #000;
}

.toast {
visibility: hidden;
min-width: 160px;
max-width: 320px;
background-color: rgba(83,82,85,0.95); /* tvoja boja sa blago providnom pozadinom */
color: #fff;
text-align: center;
border-radius: 24px;
padding: 14px 24px;
position: fixed;
bottom: 80px;
left: 50%;
transform: translateX(-50%);
font-size: 15px;
font-family: sans-serif;
box-shadow: 0 2px 10px rgba(0,0,0,0.3);
z-index: 9999;
opacity: 0;
pointer-events: none;
transition: opacity 0.25s ease-in-out, bottom 0.25s ease-in-out;
}

.toast.show {
visibility: visible;
opacity: 1;
bottom: 100px; /* blagi “slide-up” efekat */
}

/* Vrati korisnika u portrait mode*/
#portraitOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000; /* potpuno crno, neprozirno */
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-size: 18px;
  font-family: sans-serif;
  z-index: 9999;
  padding: 20px;
  box-sizing: border-box;
  display: none; /* default hidden */
}

/* sakriveni player container (izvućen iz vidokruga) */
#ytPlayerContainer {
  position: absolute;
  left: -9999px;
  top: -9999px;
  width: 1px;
  height: 1px;
  overflow: hidden;
}
</style>
</head>

<body>
<div class="player">
  <div class="top-bar">
    <div class="icon-circle" id="plusBtn"><span class="ico plus" aria-hidden="true"></span></div>
    <h1 class="app-title">Last.Fm</h1>
    <div class="icon-circle" id="heartBtn"><div class="heart" aria-hidden="true"></div></div>
  </div>

  <!-- dropdown je apsolutno pozicioniran unutar .player -->
  <div class="dropdown" id="plusDropdown" aria-hidden="true">
    <button id="startRadioBtn">Start Radio</button>
    <button id="setVarietyBtn">Set Variety</button>
  </div>

  <!-- content zauzima prostor između top-bar i controls -->
  <div class="content">
    <div class="timer" id="status"></div>
    <div class="debug" id="debugArea"></div>

    <div class="album-wrap">
      <div class="progress" style="--p:0;"></div>
      <img class="album-img" src="" alt="Artist photo" id="albumImg">
    </div>

    <div class="track-info">
      <div class="artist" id="artistName">‎ </div>
      <div class="track" id="trackName">‎ </div>
    </div>

    <div class="bio-wrap">
      <div class="bio" id="bio">‎ </div>
    </div>
  </div>

  <!-- controls uvek na dnu -->
  <div class="controls">
    <div class="ctrl small" id="stopBtn"><span class="ico stop" aria-hidden="true"></span></div>
    <div class="ctrl play" id="playBtn"><span class="ico play" aria-hidden="true"></span></div>
    <div class="ctrl small" id="nextBtn"><span class="ico next" aria-hidden="true"></span></div>
  </div>

  <div id="popupStartRadio" class="popup">
    <input type="text" id="popupInputStart" placeholder="Enter artist name">
    <button id="popupStartBtn">Start</button>
  </div>

  <div id="popupSetVariety" class="popup">
    <label>Max Similar Artists:</label>
    <input type="number" id="maxSimilarInput" value="250" min="1" max="2000">
    <label>Max Track Pages:</label>
    <input type="number" id="maxTrackInput" value="2" min="1" max="50">
    <button id="popupVarietyClose">Close</button>
  </div>
</div>

<div id="toast" class="toast"></div>

<div id="portraitOverlay">
  This app work only in portrait mode!<br>Please, rotate your device!
</div>

<!-- SKRIVENI YT IFRAME PLAYER (YouTube IFrame API će popuniti #ytPlayer) -->
<div id="ytPlayerContainer"><div id="ytPlayer"></div></div>

<script>
const PROXY_URL = 'https://mire021.mireinternet.workers.dev?url=';
let baseArtist = '', currentArtistOnScreen = '', currentVideoUrl = '', currentVideoUrlArtist = '', currentVideoUrlTrack = '', preloadCache = null;
const EMPTY_VIDEO_URL = "https://www.youtube.com/watch?v=tbnLqRW9Ef0";
let maxSimilarPages = 250, maxTrackPages = 2;

// --- Last.fm API key ---
const LASTFM_API_KEY = 'e5147a4d5b2018c3832b146b74b61061'; // ubaci svoj Last.fm API key

// --- Helper functions ---
function debug(msg) {}
function normalizeArtistForDisplay(a){ return a.replace(/\+/g,' '); }
function normalizeArtistForSearch(a){ return a.replace(/ /g,'+'); }
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

// --- Last.fm - Top Tracks
async function getRandomTopTrack(artist){
    try {
        const urlPage1 = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artist)}&api_key=${LASTFM_API_KEY}&format=json&limit=50&page=1`;
        const resPage1 = await fetch(urlPage1);
        const dataPage1 = await resPage1.json();
        const totalPages = parseInt(dataPage1.toptracks['@attr'].totalPages, 10) || 1;
        const maxPages = Math.min(totalPages, maxTrackPages);
        await sleep(1000);
        const page = Math.floor(Math.random() * maxPages) + 1;
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artist)}&api_key=${LASTFM_API_KEY}&format=json&limit=50&page=${page}`;
        const res = await fetch(url);
        const data = await res.json();
        const tracks = data.toptracks && data.toptracks.track ? data.toptracks.track.map(t => t.name) : [];
        if(tracks.length === 0) return 'Demo Track';
        return tracks[Math.floor(Math.random() * tracks.length)];
    } catch(e) {
        console.error("getRandomTopTrack failed", e);
        return 'Demo Track';
    }
}

// --- Last.fm - Similar Artists
async function getRandomSimilarArtist(){
    try{
        if(!baseArtist) return '';
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=${encodeURIComponent(baseArtist)}&api_key=${LASTFM_API_KEY}&format=json&limit=${maxSimilarPages}`;
        const res = await fetch(url);
        const data = await res.json();
        const artists = data.similarartists && data.similarartists.artist ? data.similarartists.artist.map(a=>a.name) : [];
        if(artists.length) return artists[Math.floor(Math.random()*artists.length)];
        return baseArtist;
    } catch(e){ return baseArtist; }
}

// --- Last.fm Bio + Discogs/Spotify Images
async function getArtistImagesAndBio(artist) {
    const discogsToken = "MrikosMJLcAbEUiXPnwsstSRPzQvnAEOHDEcoTaM";
    try {
        const bioAndInfo = await fetchLastFmBioShort(artist);
        const spotifyImages = await fetchSpotifyImages(artist);
        const discogsImages = await fetchDiscogsImage(artist, discogsToken);
        const images = [...spotifyImages, ...discogsImages.filter(img => !spotifyImages.includes(img))];
        return { bio: bioAndInfo, images: images.length ? images : [] };
    } catch (e) {
        console.error(e);
        return { bio: "Biography not found.", images: [] };
    }

    // --- Last.fm Biography  ---
    async function fetchLastFmBioShort(artistName) {
        try {
            const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${LASTFM_API_KEY}&format=json`;
            const res = await fetch(url);
            const data = await res.json();
            let bio = data.artist?.bio?.content?.trim() || "Biography not found.";
            let readMoreLink = "";
            const match = bio.match(/<a href="([^"]+)">.*?<\/a>/i);
            if (match) { readMoreLink = ''; bio = bio.replace(/<a href="[^"]+">.*?<\/a>/i, ""); }
            const stats = data.artist?.stats || {};
            const tags = data.artist?.tags?.tag?.map(t => t.name).join(", ") || "";
            const similar = data.artist?.similar?.artist?.map(a => a.name).join(", ") || "";
            let extra = "";
            if (stats.listeners) extra += `<br>Listeners: ${stats.listeners}`;
            if (stats.playcount) extra += `<br>Playcount: ${stats.playcount}`;
            if (tags) extra += `<br>Genre: ${tags}`;
            if (similar) extra += `<br>Similar Artists: ${similar}`;
            if (extra) extra = `<br>${extra}`;
            return `${bio}${extra}${readMoreLink}`;
        } catch (e) {
            console.error("Last.fm bio fetch failed", e);
            return "Biography not found.";
        }
    }
}

// --- Spotify Images ---
async function fetchSpotifyImages(artistName, maxImages = 10, enabled = true) {
    if (!enabled) return []; 
    try {
        const SPOTIFY_CLIENT_ID = "d7308ace981d46d385bab314f8ef0546";
        const SPOTIFY_CLIENT_SECRET = "707748e12786459dba6982c82bdd8d51";
        const resp = await fetch("https://accounts.spotify.com/api/token", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Authorization": "Basic " + btoa(SPOTIFY_CLIENT_ID + ":" + SPOTIFY_CLIENT_SECRET)
            },
            body: "grant_type=client_credentials"
        });
        const data = await resp.json();
        const token = data.access_token;
        const searchRes = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(artistName)}&type=artist&limit=50`, {
            headers: { "Authorization": `Bearer ${token}` }
        });
        const searchData = await searchRes.json();
        const artist = searchData.artists.items[0];
        if (!artist || !artist.images) return [];
        const preferredSizes = [640, 320, 160];
        let selected = [];
        for (let size of preferredSizes) {
            selected = artist.images
                .filter(img => img.width === size && img.height === size)
                .slice(0, maxImages)
                .map(img => img.url);
            if (selected.length > 0) break;
        }
        if (selected.length === 0 && artist.images.length > 0) {
            const largest = artist.images.sort((a,b) => (b.width*b.height)-(a.width*a.height))[0];
            selected = [largest.url];
        }
        return selected;
    } catch (e) {
        console.warn("Spotify image fetch failed", e);
        return [];
    }
}

// ---Discogs Images ---
async function fetchDiscogsImage(artistName, token, minWidth = 1500, minHeight = 1500, maxImages = 5, randomize = true, enabled = true) { if (!enabled) return []; 
    try {
        const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(artistName)}&type=artist&token=${token}`;
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (!searchData.results || searchData.results.length === 0) return [];
        const firstResult = searchData.results[0];
        const coverImage = firstResult.cover_image || null;
        const artistId = firstResult.id;
        await sleep(1000);
        const artistUrl = `https://api.discogs.com/artists/${artistId}?token=${token}`;
        const artistRes = await fetch(artistUrl);
        const artistData = await artistRes.json();
        if (!artistData.images || artistData.images.length === 0) {
            return coverImage ? [coverImage] : [];
        }
        let allImages = [];
        if (coverImage) {
            allImages.push({ uri: coverImage, width: 0, height: 0, area: 0, type: "cover" });
        }
        artistData.images.forEach(img => {
            allImages.push({
                uri: img.uri,
                width: img.width,
                height: img.height,
                area: img.width * img.height,
                type: img.type
            });
        });
        if (coverImage) {
            allImages = allImages.filter((img, idx, arr) => !(img.uri === coverImage && idx !== arr.findIndex(i => i.uri === coverImage)));
        }
        let candidates = allImages.filter(img => img.width >= minWidth && img.height >= minHeight);
        if (candidates.length === 0) {
            candidates = [...allImages].sort((a, b) => b.area - a.area);
        }
        let selected;
        if (randomize) {
            selected = [];
            let pool = [...candidates];
            while (pool.length > 0 && selected.length < maxImages) {
                const idx = Math.floor(Math.random() * pool.length);
                selected.push(pool[idx]);
                pool.splice(idx, 1);
            }
        } else {
            selected = candidates.slice(0, maxImages);
        }
        if (coverImage && !selected.find(img => img.uri === coverImage)) {
            if (selected.length < maxImages) {
                selected.push({ uri: coverImage, width: 0, height: 0, area: 0, type: "cover" });
            }
        }
        selected.sort((a, b) => b.area - a.area);
        return selected.map(img => img.uri);
    } catch (e) {
        console.error("Discogs image fetch failed", e);
        return [];
    }
}

// --- Carousel ---
let carouselInterval = null;
function renderCarousel(images){
    const imgEl = document.getElementById('albumImg');
    if(!images.length){ imgEl.src=''; return; }
    let idx = 0; imgEl.src = images[idx];
    if(carouselInterval) clearInterval(carouselInterval);
    carouselInterval = setInterval(()=>{ idx=(idx+1)%images.length; imgEl.src=images[idx]; }, 10000);
}

// --- YouTube search via proxy ---
const INV_INSTANCES = [
  "https://yewtu.be",
  "https://invidious.snopyta.org",
  "https://vid.puffyan.us",
  "https://invidious.kavin.rocks",
  "https://invidious.tiekoetter.com"
];

// --- Toast helper ---
function showToast(msg, duration=3000){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(()=> t.classList.remove('show'), duration);
}

// --- Advanced YouTube search + fallback Invidious + toast ---
async function searchYouTubeHtml(query){
    const BLACKLIST = ["remix","extended","album","live","mix","cover","tribute","instrumental","karaoke"];
    function containsBlacklist(str){ return BLACKLIST.some(b=>str.toLowerCase().includes(b)); }
    async function searchYTHTML(q){
        try {
            const url = `https://www.youtube.com/results?search_query=${encodeURIComponent(q)}`;
            const html = await fetch(PROXY_URL + encodeURIComponent(url)).then(r=>r.text());
            const match = html.match(/var ytInitialData = (.*?);\s*<\/script>/);
            if(!match) throw new Error("ytInitialData not found");
            const data = JSON.parse(match[1]);
            const contents = data.contents
              .twoColumnSearchResultsRenderer.primaryContents
              .sectionListRenderer.contents[0].itemSectionRenderer.contents;
            const videos = contents.filter(x=>x.videoRenderer).map(x=>x.videoRenderer);
            if(!videos.length) throw new Error("No videos found");
            const queryHasBlacklist = containsBlacklist(q);
            const artist = q.split('-')[0].trim().toLowerCase();
            const qNoDash = q.replace(/-/g,'').replace(/\s+/g,' ').trim();
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase() === q.toLowerCase()) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase().replace(/-/g,'').includes(qNoDash.toLowerCase())) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(!queryHasBlacklist && containsBlacklist(title)) continue;
                if(title.toLowerCase().includes(q.toLowerCase())) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            for(const v of videos){
                const title = v.title.runs.map(r=>r.text).join(" ");
                if(title.toLowerCase().includes(artist)) return "https://www.youtube.com/watch?v="+v.videoId;
            }
            return "https://www.youtube.com/watch?v="+videos[0].videoId;
        } catch(e) {
            throw new Error("YT HTML failed: "+e.message);
        }
    }
    async function searchInvidious(q){
        for(const baseUrl of INV_INSTANCES){
            try{
                const searchUrl = `${baseUrl}/search?q=${encodeURIComponent(q)}`;
                const html = await fetch(PROXY_URL + encodeURIComponent(searchUrl)).then(r=>r.text());
                const doc = new DOMParser().parseFromString(html,'text/html');
                const links = [...doc.querySelectorAll('a[href*="/watch?v="]')];
                const queryHasBlacklist = containsBlacklist(q);
                for(const link of links){
                    const title = link.getAttribute('title') || link.textContent;
                    if(!title) continue;
                    if(!queryHasBlacklist && containsBlacklist(title)) continue;
                    if(title.toLowerCase().includes(q.toLowerCase())){
                        const href = link.getAttribute('href');
                        return href.startsWith('http') ? href : baseUrl + href;
                    }
                }
                if(links.length){
                    const href = links[0].getAttribute('href');
                    return href.startsWith('http') ? href : baseUrl + href;
                }
            }catch(e){ continue; }
        }
        throw new Error("Invidious failed");
    }
    try{
        const url = await searchYTHTML(query);
        return url;
    }catch(e){
        console.warn("YT HTML failed, switching to Invidious:", e);
        showToast("YT HTML search failed, switching to Invidious...");
        try{
            const url = await searchInvidious(query);
            showToast("Invidious search succeeded.");
            return url;
        }catch(e2){
            showToast("Neither YT HTML nor Invidious worked!");
            throw new Error("No source available");
        }
    }
}

// --- keep buildIntentUrl for backwards compatibility (not used for playback now) ---
function buildIntentUrl(youtubeUrl){
  if(!youtubeUrl) return '';
  const clean = youtubeUrl.replace(/^https?:\/\//,'');
  return `intent://${clean}#Intent;package=org.schabi.newpipe;scheme=https;end`;
}

// --- Preload ---
async function preloadNextTrack(){
    if(!baseArtist) return;
    const pickArtist = await getRandomSimilarArtist();
    await sleep(1000); // razmak 1s
    const {images, bio} = await getArtistImagesAndBio(pickArtist);
    await sleep(1000); // razmak 1s
    const pickTrack = await getRandomTopTrack(pickArtist);
    await sleep(1000); // razmak 1s
    const youtubeUrl = await searchYouTubeHtml(`${normalizeArtistForSearch(pickArtist)} - ${pickTrack}`);
    preloadCache = { artist: pickArtist, track: pickTrack, images, bio, youtubeUrl };
}

async function loadArtist(artist) {
    baseArtist = artist;
    currentArtistOnScreen = artist;
    const appTitle = document.querySelector('.app-title');
    const originalTitle = appTitle.textContent;
    appTitle.textContent = 'Loading...';
    try {
        const { bio, images } = await getArtistImagesAndBio(artist);
        await sleep(1000);
        const pickTrack = await getRandomTopTrack(artist);
        await sleep(1000);
        const youtubeUrl = await searchYouTubeHtml(`${normalizeArtistForSearch(artist)} - ${pickTrack}`);
        document.getElementById('bio').innerHTML = bio.replace(/\n/g, '<br>');
        renderCarousel(images);
        document.getElementById('artistName').textContent = normalizeArtistForDisplay(artist);
        document.getElementById('trackName').textContent = pickTrack;
        currentVideoUrl = youtubeUrl;
        currentVideoUrlArtist = artist;
        currentVideoUrlTrack = pickTrack;
        preloadNextTrack();
    } catch (e) {
        console.error("loadArtist failed", e);
        document.getElementById('bio').textContent = "Error loading artist.";
    } finally {
        appTitle.textContent = originalTitle;
    }
}

// ---------------------------
// YOUTUBE IFRAME API (embed, hidden) - START
// ---------------------------
let ytPlayer = null;
let ytReady = false;
let ytPendingVideoId = null;

function onYouTubeIframeAPIReady() {
  ytPlayer = new YT.Player('ytPlayer', {
    height: '0',
    width: '0',
    videoId: '',
    events: {
      'onReady': onPlayerReady,
      'onStateChange': onPlayerStateChange
    },
    playerVars: {
      autoplay: 0,
      controls: 0,
      rel: 0,
      modestbranding: 1,
      origin: window.location.origin
    }
  });
}

function onPlayerReady() {
  ytReady = true;
  if(ytPendingVideoId){
    try{
      ytPlayer.loadVideoById(ytPendingVideoId);
      ytPlayer.playVideo();
    }catch(e){}
    ytPendingVideoId = null;
  }
}

function onPlayerStateChange(event){
  // WHEN VIDEO ENDS -> call next()
  if(event.data === YT.PlayerState.ENDED){
    try{ next(); }catch(e){ console.warn('next() failed on end',e); }
  }
}

// extract YouTube video id from many possible url forms
function extractYouTubeId(url){
  if(!url) return null;
  try{
    // try URL parsing
    const u = new URL(url, window.location.origin);
    // query param v
    if(u.searchParams && u.searchParams.get('v')) return u.searchParams.get('v');
    // if path contains /embed/ID or /v/ID
    const path = u.pathname || '';
    let m = path.match(/\/(?:embed|v|watch)\/([A-Za-z0-9_-]{11})/);
    if(m) return m[1];
  }catch(e){}
  // try common patterns
  let m = url.match(/(?:v=|\/embed\/|youtu\.be\/)([A-Za-z0-9_-]{11})/);
  if(m) return m[1];
  // fallback: any 11-char id in string
  m = url.match(/([A-Za-z0-9_-]{11})/);
  if(m) return m[1];
  return null;
}

// play video in hidden iframe via YT API
function playVideoUrl(url){
  const id = extractYouTubeId(url);
  if(!id){
    console.warn('Could not extract YT id from', url);
    return;
  }
  currentVideoUrl = `https://www.youtube.com/watch?v=${id}`;
  if(ytReady && ytPlayer){
    try{
      ytPlayer.loadVideoById(id);
      ytPlayer.playVideo();
    }catch(e){
      console.warn('yt play failed, storing pending', e);
      ytPendingVideoId = id;
    }
  } else {
    ytPendingVideoId = id;
  }
}

// stop player
function stopEmbeddedVideo(){
  if(ytPlayer && ytReady){
    try{ ytPlayer.stopVideo(); }catch(e){}
  }
}

// load YouTube IFrame API script
(function loadYouTubeAPI(){
  const tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
})();
// ---------------------------
// YOUTUBE IFRAME API - END
// ---------------------------

// --- Play Video --- (now uses embed)
async function play(){
    if(!currentVideoUrl) return;
    playVideoUrl(currentVideoUrl);
    // preload next in background
    try{ preloadNextTrack(); }catch(e){}
}

// ---- Next Video ---- (now uses embed)
async function next(){
    if(preloadCache){
        const {artist, track, images, bio, youtubeUrl} = preloadCache;
        currentArtistOnScreen = artist;
        document.getElementById('artistName').textContent = normalizeArtistForDisplay(artist);
        document.getElementById('trackName').textContent = track;
        document.getElementById('bio').innerHTML = bio.replace(/\n/g, '<br>');
        renderCarousel(images);
        currentVideoUrl = youtubeUrl;
        currentVideoUrlArtist = artist;
        currentVideoUrlTrack = track;
        // play in hidden embed player
        playVideoUrl(youtubeUrl);
        // preload next afterwards
        preloadNextTrack();
    }
}

//---- Stop Video ----
function stopVideo(){
    // stop embedded player
    stopEmbeddedVideo();
    // optionally clear currentVideoUrl
    currentVideoUrl = '';
}

// --- Event listeners ---
document.getElementById('playBtn').addEventListener('click', play);
document.getElementById('nextBtn').addEventListener('click', next);
document.getElementById('stopBtn').addEventListener('click', stopVideo);

const plusBtn = document.getElementById('plusBtn');
const plusDropdown = document.getElementById('plusDropdown');
plusBtn.addEventListener('click', ()=>{
  plusDropdown.style.display = plusDropdown.style.display==='flex' ? 'none' : 'flex';
});

const startRadioBtn = document.getElementById('startRadioBtn');
const setVarietyBtn = document.getElementById('setVarietyBtn');
const popupStartRadio = document.getElementById('popupStartRadio');
const popupSetVariety = document.getElementById('popupSetVariety');

startRadioBtn.addEventListener('click', ()=>{
  popupStartRadio.style.display = 'block';
  plusDropdown.style.display = 'none';
});

setVarietyBtn.addEventListener('click', ()=>{
  popupSetVariety.style.display = 'block';
  plusDropdown.style.display = 'none';
});

document.getElementById('popupStartBtn').addEventListener('click', async ()=>{
  const val = document.getElementById('popupInputStart').value.trim();
  if(val){
    popupStartRadio.style.display = 'none';
    await loadArtist(val);
    await play();
  }
});

document.getElementById('popupVarietyClose').addEventListener('click', ()=>{
  maxSimilarPages = parseInt(document.getElementById('maxSimilarInput').value) || 250;
  maxTrackPages = parseInt(document.getElementById('maxTrackInput').value) || 2;
  popupSetVariety.style.display = 'none';
});

// Hide broken image (browser)
const img = document.getElementById("albumImg");
img.onerror = () => img.style.display = "none";
img.onload = () => img.style.display = "block";

// ----Vrati korisnika u portrait mode
function checkOrientation() {
  const overlay = document.getElementById('portraitOverlay');
  if(window.innerHeight < window.innerWidth) {
    // landscape
    overlay.style.display = 'flex';
  } else {
    // portrait
    overlay.style.display = 'none';
  }
}

// inicijalna provera
checkOrientation();

// osluškuj promene orijentacije / resize
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);

</script>
</body>
</html>
